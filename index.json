[{"content":"","date":"20 十一月 2022","permalink":"/","section":"HeleneWoods的主页","summary":"","title":"HeleneWoods的主页"},{"content":"","date":"20 十一月 2022","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"简介 # 一直很好奇像苹果官网中，通过页面滚动实现的产品介绍效果是怎么做出来。\n之前有简单了解过视觉差，主要是通过设置背景图来实现的。\n今天了解到一个叫Trigger JS的库，在页面滚动时可以通过CSS变量取得动画所需要的值，而不需要额外写JS代码。\n使用方法 # Tigger JS中文文档 官方给的范例代码：\n\u0026lt;div class=\u0026#34;container\u0026#34; tg-name=\u0026#34;size\u0026#34; tg-edge=\u0026#34;inset\u0026#34; tg-from=\u0026#34;14\u0026#34; tg-to=\u0026#34;20\u0026#34; tg-bezier=\u0026#34;0.23, 1.5, 0.32, 2\u0026#34; \u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34; id=\u0026#34;content\u0026#34; tg-name=\u0026#34;opacity\u0026#34; tg-from=\u0026#34;0\u0026#34; tg-to=\u0026#34;1\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;sticky\u0026#34;\u0026gt; \u0026lt;span\u0026gt;Hello.\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; :root { font-family: Helvetica, sans-serif; font-size: 20px; --blur: 100; --opacity: 0; } body { padding: 0; margin: 0; } .container { height: 300vh; } .sticky { font-size: 10rem; font-weight: bold; letter-spacing: -0.03em; display: flex; justify-content: center; align-items: center; min-height: 100vh; position: sticky; top: 0; font-size: calc(var(--size) * 1em); } span { opacity: var(--opacity); } DOM元素上添加的tg-name属性的值就是页面滚动时需要改变的数值的CSS变量名。\n父div的tag-name属性值设为size，css代码中就可以使用--size变量，上面的例子中，在设置font-size字体大小时读取了这个css变量，calc(var(--size) * 1em)相当于给变量设置了em作为单位。\ndiv上还有tg-from和tg-to属性，代表的是size的值随着页面滚动由14变化到20，tg-bezier是用来设置动画的贝塞尔曲线的。\n而子div上的tag-name值为opacity，它的值变化是从0到1。\n我们当然也能通过监听元素的tag事件来获取到当前的值是多少：\ndocument.querySelector(\u0026#39;#content\u0026#39;).addEventListener(\u0026#39;tg\u0026#39;, (e) =\u0026gt; { console.log(e.detail); // {value: \u0026#39;1\u0026#39;} }); 以上就是这个库的大致用法。\n源码解析 # 本文不会一行一行地解释源码，而是将重点放在实现逻辑上。\n由上面的源码结构图可以看出我们需要着重解读的是trigger.ts中的代码。\n在index文件中调用了Trigger.start()方法，先来看看这个方法是什么：\nconst Trigger: TriggerType = { start() { if (!document.body) { console.warn(`Unable to initialise, document.body does not exist.`); return; } observeElements(); eventListeners(); }, }; 方法里调用了两个私有函数：\n// 初始化元素监听 function observeElements() { // observer是对IntersectionObserver API的封装，传入一个回调函数 ob = observer((entries) =\u0026gt; { entries.forEach((entry) =\u0026gt; { // target：目标元素 let { target } = entry; // 判断元素是否在当前视窗中 if (entry.isIntersecting) { /* 通过调用parseAttributes方法获取HTML上所有自定义属性的值， 并返回一个带有原始el对象和所有属性值的对象 { el: element, top, height, name, from, to, steps, step, mapping, filter, edge, range, increment, segments, decimals, multiplier, lastValue: null, bezier, } 方便后续监听scroll事件时获取； 把对象推入到一个监听数组中存起来 */ activeElements.push(parseAttributes(target as HTMLElement)); } else { // 如果元素不在视窗中就从监听数组中移除 activeElements = activeElements.filter(function (obj) { return obj.el !== target; }); } }); }); } function eventListeners() { window.addEventListener(\u0026#39;DOMContentLoaded\u0026#39;, () =\u0026gt; { /* bind()是对IntersectionObserver.observe()方法的封装，监听所有在视窗中的元素 并添加两个钩子函数，before()和after()，在监听窗口resize事件时会使用到 */ bind(ob); setTimeout(() =\u0026gt; { // 一开始就获取所有带有自定义属性的元素，并解析元素的属性值，保证页面滚动前可以获取到正确的样式 let allElements = [ ...document.querySelectorAll(`[${getPrefix()}name]`), ].map((element) =\u0026gt; { return parseAttributes(element as HTMLElement); }); /* parseValues是这个库最核心的计算方法，当监听到滚动事件时就会调用这个方法 在这个方法中不仅会设置相应的style属性值 并且当属性值发生变化的时候会将自定义tg事件通过el.dispatchEvent方法派发到监听的元素上 */ parseValues(allElements); }); }); // 当窗口大小发生变化时重新监听元素 window.addEventListener(\u0026#39;resize\u0026#39;, () =\u0026gt; { bind(ob, { // 调用 IntersectionObserver.observe()方法之前的钩子函数 before: () =\u0026gt; { // 解除所有监听数组中元素的监听 activeElements.forEach((element) =\u0026gt; { ob?.unobserve(element.el); }); // 清除监听数组 activeElements = []; }, }); }); // 监听滚动事件，改变当前视窗内元素的属性值 window.addEventListener(\u0026#39;scroll\u0026#39;, (e) =\u0026gt; { parseValues(activeElements); }); } 实现逻辑 # 通过对trigger.ts代码的阅读，可以看出整个库最主要的实现原理就是通过IntersectionObserver对元素进行监听，然后使用parseValues()方法计算并设置元素的属性值。\n","date":"20 十一月 2022","permalink":"/posts/triggerjs/","section":"Posts","summary":"简单介绍了Trigger JS的使用方法及源码。","title":"开源库学习之Trigger JS"},{"content":"什么是作用域 # 作用域就是代码中定义变量的区域。\n作用域规定了当前执行代码对变量的访问权限。\nJavascript采用的是静态作用域。\n静态作用域与动态作用域 # 静态作用域就是在函数定义的时候，它的作用域就被决定了。\n动态作用域是函数在被调用的时候，作用域才被定义。\nvar value = 1; function foo() { console.log(value); } function bar() { var value = 2; foo(); } bar(); // 1 上面的例子执行了bar()函数，函数里又调用了foo()函数，既然js是静态作用域，那么就在它定义的地方去找value，foo()函数内部没有定义value，就去上一层找，在全局定义了一个变量value = 1。\nvar scope = \u0026#34;global scope\u0026#34;; function checkscope(){ var scope = \u0026#34;local scope\u0026#34;; function f(){ return scope; } return f(); } checkscope(); var scope = \u0026#34;global scope\u0026#34;; function checkscope(){ var scope = \u0026#34;local scope\u0026#34;; function f(){ return scope; } return f; } checkscope()(); 上面的例子最后输出的结果都是\u0026quot;local scope\u0026quot;，因为是静态作用域，不管f()是在哪执行的，找的都是f()函数外部的那个声明变量。\n但这两段代码还是有明显的不一样，那就是f()函数的执行上下文（执行环境）不同。\n执行上下文 # 一般会认为，Javascript代码是顺序执行的，但如果遇到下面这种情况：\nfunction foo() { console.log(\u0026#39;foo1\u0026#39;) } foo() // \u0026#39;foo2\u0026#39; function foo() { console.log(\u0026#39;foo2\u0026#39;) } foo() // \u0026#39;foo2\u0026#39; 我们定义了两次foo()，但两次执行结果都是一样的，为什么？\n因为JS引擎并不是一行一行对代码分析和执行的，而是一段一段地分析执行。上面的例子实际上触发了函数提升\n那么这个一段要怎么去划分呢？这就是下面需要讲到的内容了。\n执行上下文栈 # JS的可执行代码类型有三种：全局代码、函数代码、eval代码。\n如果执行到一个函数的时候，就会进行一个准备工作，这个准备工作就可以被认为是执行上下文。\n但是代码中不可能只有一个函数，为了管理这些函数的执行上下文，JS引擎创建了执行上下文栈。\n我们可以定义一个数组来模拟执行上下文栈的行为\nESCtack = [] 首先遇到的肯定是全局代码，就将全局执行上下文压入到执行上下文栈中ECStack = [globalContext];，全局执行上下文直到整个应用结束了才会被弹出。\n然后我们再回到这一节一开始的那个例子，它定义在全局，也就是那么多行代码作为一段代码被globalContext一起压入了执行上下文栈中。\n而重复声明foo函数，导致后面的函数覆盖了前面的，所以执行结果是一样的。为什么会覆盖呢？就得继续学习**变量对象**才能理解了。这里先按下不表。\n我们来看另一段代码：\nfunction fun3() { console.log(\u0026#39;fun3\u0026#39;) } function fun2() { fun3(); } function fun1() { fun2(); } fun1(); 现在需要执行fun1()函数，这时会创建一个执行上下文并压入栈中，当要执行的时候发现函数了还调用了另一个函数fun2()，又要创建一个执行上下文压入栈中，但里面又调用了fun3()，再创建一个执行上下文压入栈中。没有其它函数代码了就开始按照后进先出的顺序执行函数，每执行一个就从栈中弹出。这段过程的伪代码可以写成这样：\n// 伪代码 ECStack.push(\u0026lt;fun1\u0026gt; functionContext); // fun1中竟然调用了fun2，还要创建fun2的执行上下文 ECStack.push(\u0026lt;fun2\u0026gt; functionContext); // 擦，fun2还调用了fun3！ ECStack.push(\u0026lt;fun3\u0026gt; functionContext); // fun3执行完毕 ECStack.pop(); // fun2执行完毕 ECStack.pop(); // fun1执行完毕 ECStack.pop(); // javascript接着执行下面的代码，但是ECStack底层永远有个globalContext 参考上面的代码，我们给上一节最后的那两段代码写一个执行上下文栈的流程：\nECStack.push(\u0026lt;checkscope\u0026gt; functionContext); ECStack.push(\u0026lt;f\u0026gt; functionContext); // f 执行完毕 ECStack.pop(); // checkscope 执行完毕 ECStack.pop(); ECStack.push(\u0026lt;checkscope\u0026gt; functionContext); // checkscope 执行完毕 ECStack.pop(); ECStack.push(\u0026lt;f\u0026gt; functionContext); // f 执行完毕 ECStack.pop(); 变量对象 # 每个执行上下文里都有个变量对象(variable object)，执行上下文中定义的所有变量和函数都保存在这个对象中，但我们无法访问这个对象。\n上一节有提到JS的可执行代码有三种，它们都有执行上下文，而不同执行上下文的变量对象也会有点不同。\n全局上下文 # 全局上下文的变量对象就是全局对象，也就是window对象。\n所有对象都是Object构造函数的实例，window对象也不例外：\nconsole.log(this instanceof Object); // true 全局对象预定义了一堆函数和属性，可以直接调用，也可以通过this或window调用:\n// 都能生效 console.log(Math.random()); console.log(this.Math.random()); console.log(window.Math.random()); 全局对象是全局变量的宿主\nvar a = 1; console.log(window.a); // 1 console.log(this.a); // 1 this.window.b = 2; console.log(this.b); // 2 函数上下文 # 在函数上下文中，变量对象变成了活动对象(activation object, AO)，只有在进入一个执行上下文中时，这个执行上下文中的变量对象才被激活，而活动对象上的属性时可以被访问的。\n执行流程 # 上文提到，JS代码在执行前会有个准备工作，也就是生成执行上下文，然后进入执行上下文，最后再执行。\n进入执行上下文 # 这时代码并没有执行，变量对象包括：\n函数的所有形参(Arguments对象) 通过函数的arguments属性初始化，传入的所有值都会变成它的数组元素 由名称和对应值组成的一个变量对象的属性被创建 没有实参，属性值设为undefined 函数声明 由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建 如果变量对象已经存在相同名称的属性，则完全替换这个属性（函数提升） 变量声明 由名称和对应值（undefined）组成一个变量对象的属性被创建 如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性 是不是看到函数提升了？前面那个例子还记得吗？声明了两次foo函数，后面的替换了前面的导致两次执行的结果是一样的。\n回到正题，再举个例子：\nfunction foo(a) { var b = 2; function c() {} var d = function() {}; b = 3; } foo(1); 进入执行上下文时的AO是这样的：\nAO = { arguments: { 0: 1, length: 1 }, a: 1, b: undefined, c: reference to function c(){}, d: undefined } 代码执行 # 执行后AO的变化：\nAO = { arguments: { 0: 1, length: 1 }, a: 1, b: 3, c: reference to function c(){}, d: reference to FunctionExpression \u0026#34;d\u0026#34; } 其实变量对象和活动对象是同一个对象，只是处于执行上下文的不同生命周期，在没有进入执行上下文之前是无法访问的，进入之后可以访问，执行之后属性就根据代码完成了赋值。\n思考题 # function foo() { console.log(a); a = 1; } foo(); // 报错 function bar() { a = 1; console.log(a); } bar(); // 1 第一个函数会直接报错，因为并没有使用var对变量进行声明，所以不会被存放在AO当中。\n而第二个函数虽然也没声明，但在打印变量前，已经将变量a赋值给了全局对象。\n我们稍微改一个第一个函数：\nfunction foo() { console.log(a); var a = 1; } foo(); // undefined 没有报错，但输出的是undefined，因为声明后会被加入到AO中，这就是为什么var会造成变量提升，但只是声明提升了，并没有赋值。 那如果改成这样呢：\nfunction foo() { console.log(a); } a = 1; foo(); // 1 输出的是1，这是因为a是全局对象，在进入函数的执行上下文的时候就已经声明并赋值完了。\n再来一个例子：\nconsole.log(foo); function foo(){ console.log(\u0026#34;foo\u0026#34;); } var foo = 1; 最终输出的是foo()函数，而不是1，因为进入执行上下文中时会先处理函数声明，然后才是变量声明，又如前面对变量声明对定义所说如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。\n作用域链 # 其实在执行上下文中不仅会有变量对象，还有作用域链和this，这一小节就来介绍一下作用域链。\n前文提到，在查找变量时，首先会在当前执行上下文查找，如果没有就词法层面上的父级上下文里找，一直找到全局对象。\n这样由多个执行上下文变量对象构成的链表叫做作用域链。\n创建流程 # 一开始我们就有提到，JS使用的是静态作用域，当函数被定义的时候，作用域就被决定了。\n因为函数内部有一个[[scope]]属性，当函数被创建时，会自动把父级变量对象保存在里面。\n比如有这么一个函数：\nfunction foo() { function bar() { } } 函数里面还有个函数，它们各自的[[scope]]为：\nfoo.[[scope]] = [ globalContext.VO ] bar.[[scope]] = [ fooContext.AO, globalContext.VO ] 但[[scope]]属性并不是完整的作用域链。\n当函数被激活之后，进入到执行上下文中创建VO/AO，将活动对象添加到作用域链的前端，这才是完整的作用域链：\nScope = [AO].concat([[scope]]) 最后我们结合前几节的内容，加上执行上下文栈和变量对象来模拟一下它们的创建流程：\nvar scope = \u0026#34;global scope\u0026#34;; function checkscope(){ var scope2 = \u0026#39;local scope\u0026#39;; return scope2; } checkscope(); 函数被创建，保存父执行上下文变量对象到[[scope]]属性： checkscope.[[scope]] = [ globalContext.VO ] 准备执行checkscope函数，创建执行上下文，将它压入到执行上下文栈中： ECStack = [ checkscopeContext, globalContext ] 开始做准备工作，复制[[scope]]属性，开始创建作用域链 checkscopeContext = { Scope: checkscope.[[scope]] } 用arguments创建活动对象，将其初始化，加入形参、函数声明、变量声明 checkscopeContext = { AO: { arguments: { length: 0 }, scope2: undefined // 变量声明 }, Scope: checkscope.[[scope]] } 将活动对象压入作用域顶端 checkscopeContext = { AO: { arguments: { length: 0 }, scope2: undefined // 变量声明 }, Scope: [AO, checkscope.[[scope]]] } 准备工作完毕，开始执行函数，改变AO属性值 checkscopeContext = { AO: { arguments: { length: 0 }, scope2: \u0026#39;local scope\u0026#39; // 变量声明 }, Scope: [AO, checkscope.[[scope]]] } 函数执行完毕，函数执行上下文从执行上下文栈中弹出 ECStack = [ globalContext ] 闭包 # 闭包是可以访问自由变量的函数。 啥是自由变量呢？就是指在函数中被使用，但既不是函数参数又不是函数的局部变量。\n又有句话说，所有JS函数都是闭包，就比如：\nvar a = 1 function foo() { console.log(a) } foo() foo()访问了全局对象里的变量a，再看看上面的定义，可不就是个闭包吗？\n理论上确实如此，但实践中的闭包却不太一样。\n从实践角度对闭包的定义是：\n代码中使用了自由变量； 即使创建它的上下文已经销毁了，它依然存在。 我们结合上面作用域相关的知识来理解第二点：\nvar scope = \u0026#34;global scope\u0026#34;; function checkscope(){ var scope = \u0026#34;local scope\u0026#34;; function f(){ return scope; } return f; } var foo = checkscope(); foo(); 参考前几节用为代码来谢谢这段代码的执行流程：\n// 保存checkscope的父级执行上下文变量对象 checkscope.[[scope]] = [global.VO] // checkscope执行上下文创建 ECStack = [checkscopeContext, globalContext] // 进入checkscope执行上下文，先复制一份刚刚创建的不完整的作用域链 checkscopeContext = { Scope: checkscope.[[scope]] } // 然后初始化AO checkscopeContext = { AO: { arguments: { length: 0 }, scope: undefined, f: reference to function f(){} }, Scope: checkscope.[[scope]] } // 把AO压入到作用域链顶端 checkscopeContext = { AO: { arguments: { length: 0 }, scope: undefined, f: reference to FunctionExpression \u0026#34;f\u0026#34; }, Scope: [AO, checkscope.[[scope]]] } // 执行checkscope，改变AO checkscopeContext = { AO: { arguments: { length: 0 }, scope: local scope, f: reference to function f(){} }, Scope: [AO, checkscope.[[scope]]] } // 执行完毕，弹出执行上下文栈 ECStack = [globalContext] // 准备执行f，保存f的父级执行上下文变量对象 f.[[scope]] = [checkscope.AO, global.VO] // f的执行上下文压入执行上下文栈中 ECStack = [fContext, globalContext] // 进入checkscope执行上下文，复制一份刚刚创建的不完整的作用域链 fContext = { Scope: [f.[[scope]]] } // 初始化AO，并压入作用域链顶端 fContext = { AO: { arguments: { length: 0 }, } Scope: [AO, f.[[scope]]] } // 后面就是执行出栈，和上面大同小异，就省略了 写了这么多，其实就是想要看看f()的作用域链里包含了些啥，f.[[scope]]里面存放了checkscope函数的AO，所以f()执行的时候要返回的scope的值会在作用域链里的checkscope.AO中找到，这就是为什么checkscopeContext已经销毁了，但依然能访问到里面的变量对象。这就是所谓的闭包！\n","date":"4 十一月 2022","permalink":"/posts/scoping/","section":"Posts","summary":"一步步讲解什么是执行上下文、变量对象、作用域链，从而对作用域有个比较深入的了解，然后通过对作用域的深层理解来解释什么是闭包。","title":"JS基础之作用域"},{"content":"什么是原型 # 当我们用一个构造函数创建一个实例对象的时候，实例对象里就产生了一个指针指向了它的原型。\n这个原型就是构造函数的原型对象。\nfuction Person() { } var person = new Person() console.log(person.__proto__ === Person.prototype) // true 每个构造函数都有一个原型对象，并且这个原型中有个指针指向构造函数。\nconsole.log(Person.prototype.constructor === Person) // true 以上的关系就如下图所示 原型的原型 # 上面我们提到过，原型其实就是个对象，既然是个对象，我们就能通过new Object()的方式创建它，由此可见，Person.prototype里也有个指针指向了Object.prototype，将这层关系补充到图示上： 原型链 # function Person() { } Person.prototype.name = \u0026#39;Kavin\u0026#39; var person = new Person() person.name = \u0026#39;Helen\u0026#39; console.log(person.name) // \u0026#39;helen\u0026#39; delete person.name console.log(person.name) // \u0026#39;kevin\u0026#39; 当我们想要获取实例属性时，首先会在实例中查找，如果没有，就会在实例的原型中查找，如果还没有，就继续查找原型的原型，直到最后Object.prototype的原型指向null才停止。\n这就是所谓的原型链。 需要注意的问题 # constructor # 前面有提到，实例对象中有个指针指向构造函数，这个指针就是constructor。\n以上面的例子，我想要获取person.constructor，而实例person上并没有这个属性，但原型上有啊，所以我们实际获得的是Person.prototype.constructor。\nconsole.log(person.constructor) // function Person() {} proto # 前面有提到原型的原型指向Object.prototype的问题，但Person.prototype里并没有__proto__这个属性，却可以因此获取到Object.prototype，这是为什么？\n与其说这是个属性，不如理解成数据劫持里的getter/setter，每次读取时都返回的是Object.getPrototypeOf(obj)方法。\n继承 # ECMAScript将原型链作为实现继承的主要方法，通过原型让一个引用类型继承另一个引用类型的属性和方法。\nfunction Father() { this.son = \u0026#39;Ross\u0026#39; } Father.prototype.getSonName = function() { return this.son } function Son() { this.father = \u0026#39;Jake\u0026#39; } Son.prototype = new Father() // 继承自Father son.prototype.getFatherName = function() { return this.father } var family = new Son() console.log(family.getSonName) // \u0026#39;Ross\u0026#39; 上面的例子是通过创建Father的实例然后赋值给Son.prototype的方法实现继承的，也就是重写原型对象。\n如果我们获取family.father属性，会直接从family对象上找到，因为它是Son的实例对象，father是Son定义的一个实例属性，因为this指向的就是这个构造函数创建的实例对象。而family.son属性则会在family的原型Son.prototype上找到，因为它是Father的实例对象。\n也正由于原型链的这一特性，导致包含引用类型值的原型属性会被所有实例共享。\nfunction SuperType() { this.color = [\u0026#39;black\u0026#39;, \u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;] } function SubType() { } SubType.prototype = new SuperType() var instance1 = new SubType() instance1.color.push(\u0026#39;yellow\u0026#39;) var instance2 = new SubType() console.log(instance2) // [\u0026#39;black\u0026#39;, \u0026#39;red\u0026#39;, \u0026#39;green\u0026#39;, \u0026#39;yellow\u0026#39;] 我们通过第一个实例改变了原型上的属性color，导致第二个实例上的color属性也发生了变化，就是因为它们读取的是同一个引用类型。\n","date":"4 十一月 2022","permalink":"/posts/prototype/","section":"Posts","summary":"主要介绍了什么是原型和原型链，以及原型链存在的问题。","title":"JS基础之原型"},{"content":"什么是MVVM # MVVM是一种视图模型双向绑定的设计模式，是Model-View-ViewModel的缩写，是从MVC模式演变过来的。\nModel层代表数据模型，View代表UI组件，ViewModel是前两者之间的桥梁，数据会绑定到ViewModel层，并将数据渲染到页面上，视图变化时会通知ViewModel更新数据。\n以前是操作DOM结构更新视图，现在是数据驱动视图。\nMVVM的优点 # 低耦合：在MVC模式中View强依赖Model，导致View无法进行组件化设计；现在View可以独立于Model变化和修改，一个Model可以绑定到不同View上 可重用性：我们可以吧一些视图逻辑放在一个Model里，让很多View重用这段视图逻辑 独立开发：开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员就专注页面设计 可测试：在MVC中，View需要UI环境，因此依赖View的Controller测试会变得很困难 Vue的底层逻辑 # Vue是个典型的MVVM框架，它实现了数据与视图的双向绑定。\n它是采用数据劫持结合发布订阅者模式来实现这一逻辑的。\nObserver # 数据监听器，主要功能是对数据进行劫持，核心功能是通过Object.defineProperty()方法实现的，每当获取数据时，会触发方法内部的getter函数，将订阅者（Watcher）添加到订阅器（Dep）中；当数据发生变化的时候就触发setter函数，通知订阅者进行视图更新。\nWatcher # 订阅者，作为Compile和Observer之间通信的桥梁，主要的职责是：\n在Compile运行时实例化自身，生成需要传递给update()方法的回调函数 在Observer监听到获取数据时，往Dep中添加自己的实例 自身实例都会有一个update()方法，数据发生变化的时候，Dep.notify()给订阅者发布消息，触发update()方法 Compile # 指令解析器，就是用来解析模板指令的，主要的工作是：\n把模板中的变量替换成响应的数据，然后初始化渲染页面视图。 生成订阅者更新视图时需要调用的回调函数 给每个指令对应的节点绑定更新函数，实现数据的双向绑定。 Vue的生命周期 # 对于生命周期，官方文档是这么解释的：\n每个 Vue 实例在被创建时都要经过一系列的初始化过程——例如，需要设置数据监听、编译模板、将实例挂载到 DOM 并在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，这给了用户在不同阶段添加自己的代码的机会。\n依然是官方给的生命周期图示： 红字部分就是生命周期钩子，可以很清晰地看出它们执行的先后顺序。 文字描述这个过程大概就是：\n创建阶段 beforeCreat：创建前，data和methods中的数据都还没初始化 created：创建完，数据初始化完成，能够获取到data中的值 编译阶段 beforeMount：进行模板编译 mounted：将数据挂载到视图上，可以获取和操作DOM 更新阶段 beforeUpdate：监测到数据的变化，触发虚拟DOM的重新渲染 updated：视图更新完成 销毁阶段 beforeDestroy：实例销毁前，可以手动销毁一些方法 destroyed：销毁后 组件生命周期 # 父组件beforeCreate \u0026ndash;\u0026gt; 父组件created \u0026ndash;\u0026gt; 父组件beforeMount \u0026ndash;\u0026gt; 子组件beforeCreate \u0026ndash;\u0026gt; 子组件created \u0026ndash;\u0026gt; 子组件beforeMount \u0026ndash;\u0026gt; 子组件 mounted \u0026ndash;\u0026gt; 父组件mounted \u0026ndash;\u0026gt;父组件beforeUpdate \u0026ndash;\u0026gt;子组件beforeDestroy\u0026ndash;\u0026gt; 子组件destroyed \u0026ndash;\u0026gt; 父组件updated\n规律就是，子组件在父组件数据挂载前才开始初始化，直到子组件挂载完毕父组件才挂载完毕；子组件的更新或者销毁都会触发父组件更新，直到子组件更新或销毁完毕，父组件才更新完毕；在销毁阶段同理，得在子组件销毁完毕后父组件才会触发destroyed钩子函数。\ncomputed和watch的区别 # watch：是一个对象，键是需要监听已在data中定义的属性，值是对应的回调函数。当监听的属性发生变化时，触发watch中的方法，通常需要执行异步或者开销较大的操作时使用\ncomputed：计算属性是用来声明式的描述一个值依赖了其它的值，computed中的函数必须用return返回结果。只有当它依赖的属性发生变化时，才会调用函数重新计算，否则会直接从缓存中读取结果。\n所以相比watch来说，computed更加高效，如果二者都能实现的功能，推荐优先使用computed。\n如何实现一个computed # computed的用法是这样的\ndata: () { return { a: 1, b: 2, name: \u0026#39;helene\u0026#39; } }, computed: { sum() { return this.a + this.b }, myName: this.name } computed里的值可能是个函数，也可能是个对象，computed函数就能这么写\n// 将vue实例传进来 function initComputed(vm) { // 获取到computed对象 const computed = vm.$options.computed // 听过Object.keys()方法将computed对象的key转化成数组 Object.keys(computed).forEach(key =\u0026gt; { // 数据代理,获取方法时不用写成vm.$options[key]，直接vm[key]就能获取了 Object.defineProperty(vm, key, { /** * 判断computed里的值是对象还是函数， * 是函数就直接运行，读取依赖的值时会自动调用getter方法； * 是对象就手动调用get方法 */ get: typeof computed[key] === \u0026#39;function\u0026#39; ? computed[key] : computed[key].get, set() {} }) }) } 组件中的data为什么是一个函数 # 一个组件可以复用多次，这样会创建出多个实例，但本质都是由一个构造函数创建的。如果data是一个对象的话，那么data就是一个引用类型，当我们修改一个实例的data属性时，其它实例的属性会跟着一起变化。为了防止数据污染，data必须是一个函数，这样里面的属性就有自己的作用域了。\nvue的路由原理 # 首先，为什么要使用路由？ 众所周知，vue生成的页面是单页面(SPA)。服务器上只有一个由前端生成的index.html静态文件，用户在页面上点击操作不会触发http请求新的静态文件index.html，但依然可以做到局部刷新数据，让用户体验到反馈，这就是路由的作用。\n路由有两种模式，hash模式和history模式。\nhash模式 # hash模式URL长这样\n首页：yourdomain.xxx.com/index.html/#/ 博文：yourdomain.xxx.com/index.html/#/posts #号后面的内容就是hash部分，不同显示内容对应的hash不同，路由就是通过监听hash的变化进行相应的内容渲染的。 实现hash模式的核心就是浏览器暴露给开发者的hashchange方法。 class VueRouter { constructor(routes = []) { // 获取路由映射 this.routes = routes this.currentHash = \u0026#39;\u0026#39; this.refresh = this.refresh.bind(this) // 监听加载和路由变化事件，调用refresh方法 window.addEventListener(\u0026#39;load\u0026#39;, this.refresh, false) window.addEventListener(\u0026#39;hashchange\u0026#39;, this.refresh, false) } // 获取hash值 getUrlPath(url) { return url.indexOf(\u0026#39;#\u0026#39;) \u0026gt;= 0 ? url.slice(url.indexOf(\u0026#39;#\u0026#39;) + 1) : \u0026#39;/\u0026#39; } refresh(event) { let newHash = \u0026#39;\u0026#39; let oldHash = null if (event.newURL) { oldHash = this.getUrlPath(event.oldURL || \u0026#39;\u0026#39;) newHash = this.getUrlPath(event.newURL || \u0026#39;\u0026#39;) } else { newHash = this.getUrlPath(window.location.hash) } // 记录当前路由的hash值 this.currentHash = newHash // 通过hash值获取相应组件内容 this.matchComponent() } matchComponent() { // 找到路由映射中与当前hash匹配的路由数据 let currentRoute = this.routes.find(route =\u0026gt; route.path === this.currentHash) if(!currentRoute) { // 如果没有数据匹配就返回到首页（根据具体场景可能有所不同 currentRoute = this.routes.find(route =\u0026gt; route.paht === \u0026#39;/\u0026#39;) } // 获取到组件数据 const { component } = currentRoute // 将数据挂载到DOM上 documnet.querySelector(\u0026#39;#content\u0026#39;).innerHTML = component } } const router = new VueRouter([ { path: \u0026#39;/\u0026#39;, name: \u0026#39;home\u0026#39;, component: \u0026#39;\u0026lt;div\u0026gt;首页\u0026lt;/div\u0026gt;\u0026#39; }, { path: \u0026#39;/\u0026#39;, name: \u0026#39;posts\u0026#39;, component: \u0026#39;\u0026lt;div\u0026gt;博文\u0026lt;/div\u0026gt;\u0026#39; } ]) 从代码可以看出，hash模式可以完全由前端实现。\nhistory模式 # history模式的核心是HTML5提供的一个history全局对象，它记录了用户在访问页面时留下的历史会话信息，同时这个对象中的一些方法可以对浏览器历史会话进行操作。\nwindow.history.go：可以跳转到浏览器历史会话中指定的某一个记录页 window.history.forward：跳转到历史会话中的下一页 window.history.back：跳转到历史会话中的上一页 window.history.pushState：将数据压入历史回话栈中 window.hisotry.replaceState：将当前回话页信息替换成指定数据 其实不论hash模式还是history模式，我们都是通过监听url的变化来实现数据更新的。 通过上面对history方法的介绍可以看出来，如果我们能够监听到pushState和replaceState事件的触发，就能够更新页面数据了。但这两个方法只能改变URL却并不能触发页面的刷新，这是为什么？\n我们还要了解window在处理历史会话发生变化时触发的事件popstate，它只会在浏览器行为下触发，比如点击前进、后退键，history.replaceState()和history.pushState无法触发popstate。\n那我们只能手动将这两个方法的事件监听器注册到window上了。\nlet _wr = function(type) { let orig = history[type] return function() { // 改变原始方法的this指向 let rv = orig.apply(this, arguments) // 初始化事件 let e = new Event(type) // 将原方法调用的参数传给新创建的事件对象 e.arguments = arguments // 将事件派发给window，当事件调用时，会触发EventListener window.dispatchEvent(e) return rv } } history.pushState = _wr(\u0026#39;pushState\u0026#39;) history.replaceState = _wr(\u0026#39;replaceState\u0026#39;) 然后我们就可以在监听回调中处理页面渲染了，思路和hash的实现大同小异。\n但history模式有个问题，一旦刷新，页面会报404。 因为没刷新，不论我们怎么通过pushState改变URL，都是访问默认路径yourdomain.xxx.com下的index.html文件，刷新后就变成访问yourdomain.xxx.com/posts下的index.html文件了，但服务器上并没有这个路径资源。这种时候就需要配置nginx代理服务器，告诉服务器如果路径资源不存在，默认指向静态资源index.html。\n","date":"27 十月 2022","permalink":"/posts/vue/","section":"Posts","summary":"从我学完js后就开始接触vue，可以说我的前端生涯都是vue给的，但是就算这样我也不敢说自己很懂vue，姑且写一篇文来记录一下目前为止我对vue的理解吧。","title":"关于Vue的深刻以及不深刻理解"},{"content":"this是什么 # 它是JS中的一个关键字，被自动定义在所有函数的作用域中。\nthis提供了一个更优雅的方式来隐式“传递”一个对象引用。我们需要搞清楚的就是this到底指向了哪里。\n对this最常见的误解是把它理解成指向函数自身，我更喜欢理解成是指向调用该函数的对象。\nthis的绑定规则 # 默认绑定 # 最常用也最简单的独立函数调用，直接使用不带任何修饰的函数引用进行调用。\nfunction foo() { console.log(this.a) } var a = 2 foo() // 2 这种调用方式this指向的是全局对象window，所以打印结果是申明的变量a。\nfunction foo() { this.count++ } foo.count = 0 foo() console.log(foo.count) // 0 上面这个例子为什么foo.count输出结果为0？就是因为foo函数被调用时this指向的是全局对象window，而不是对象foo。\n函数调用链（一个函数调用另一个函数），以及将函数作为参数传入另一个函数中，也会造成默认绑定。\n在严格模式下，全局对象不能用于默认绑定，所以this会绑定到undefined。\n隐式绑定 # 一般的对象调用 # 通过某个对象调用的函数\nfunction foo() { console.log(this.a) } const b = { a: 2, foo: foo } b.foo() // 2 foo()是被对象b调用的，所以this指向的是对象b。\n对象属性引用链 # 当函数被对象属性链式调用时，只有调用对象的上一层作用域会被绑定到this上。\nfunction foo() { console.log(this.a) } const obj1 = { a: 1, foo: foo } const obj2 = { a: 2, obj1: obj1 } obj2.obj1.foo() // 1 这里函数foo()的上一层调用是obj1，所以this指向的是obj1。\n隐式丢失 # 这就是为什么this的指向问题这么让人摸不着头脑，因为有些隐式绑定会导致绑定对象的丢失，最终应用的是默认绑定。\n当我们把对象里的函数赋值给一个全局变量再调用时，this就指向了全局对象window。\nfunction foo() { console.log(this.a) } var obj = { a: 1, foo: foo } var bar = obj.foo var a = 2 bar() // 2 传入回调函数，也就是前面所说的作为参数传入函数，造成默认绑定。\nfunction foo() { console.log(this.a) } function doFoo(fn) { fn() } var obj = { a: 1, foo: foo } var a = 2 doFoo(obj.foo) // 2 显式绑定 # JS内置方法 # call()和apply()方法的第一个参数就是用来指定调用该方法的函数的this指向的对象。\nfunction foo() { console.log(this.a) } var obj = { a: 2 } foo.call(obj) // 2 函数foo的this被指定给了obj。\n如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当作 this 的绑定对 象，这个原始值会被转换成它的对象形式（也就是 new String(..)、new Boolean(..) 或者 new Number(..)）。\n还有个bind()方法，它和call、apply不同的是，它会返回一个新的函数，这个新函数的this就指向了传入的参数。\nfunction foo(num) { console.log(this.a, num) return this.a + num } var obj = { a: 2 } var bar = foo.bind(obj) var b = bar(3) // 2 3 console.log(b) // 5 其实JS内置函数里都能够传入参数指定this指向，比如forEach()，第一个参数是一个回调函数，第二个参数就是指定回调函数的this指向。\nnew绑定 # 当你new一个对象时，js为你做了哪些工作？\n创建一个新对象 新对象的prototype属性指向构造函数的原型对象 构造函数的this指向新对象 通过构造函数初始化新对象 如果构造函数返回一个非空对象，则返回该对象；否则返回刚创建的新对象 绑定规则优先级 # 默认绑定 \u0026lt; 隐式绑定 \u0026lt; 显示绑定 \u0026lt; new绑定\n箭头函数 # 箭头函数的this指向是最特殊的，它本身没有this，只能通过查找作用域链获得this值，所以它根据执行上下文决定this指向的。\nvar a = 1 function foo() { console.log(\u0026#39;foo\u0026#39;, this.a) } var boo = { a: 2, foo: foo, fn: () =\u0026gt; { console.log(\u0026#39;fn\u0026#39;, this.a) } } boo.foo() // 2 boo.fn() // 1 foo()this指向boo对象，而fn()this指向的是window，虽然fn()是被boo调用的，但它需要获取boo的this指向，就是window。\n其它意外 # 被忽略的this # 当使用call、apply或bind方法显示绑定this时，如果传入的值是null、undefined，this还是会指向全局。\nfunction foo() { console.log(this.a) } var a = 2 foo.call(null) // 2 foo.call(undefined) // 2 foo.bind(null)(); 间接引用 # function foo() { console.log(this.a) } var a = 2 var o = { a: 3, foo: foo } var p = { a: 4 } o.foo(); // 3 // 函数赋值 (p.foo = o.foo)() // 2 console.log(p.foo) // foo(){ console.log(this.a) } p.foo = o.foo赋的值是目标函数的引用，因此调用执行的实际是foo()函数，而不是p.foo()也不是o.foo()，所以这里应用的是默认绑定。\n","date":"26 十月 2022","permalink":"/posts/this/","section":"Posts","summary":"介绍this绑定的四个规则，彻底弄懂this的指向问题。","title":"一篇文章搞懂this"},{"content":"什么是BFC # BFC：全称Bloc Formatting Context，中文就是块级格式上下文。 它是W3C CSS2.1规范中的一个概念，决定了元素如何对其内容进行定位，以及与其它元素的关系和相互作用。\n通俗点就是，它对元素的布局会产生影响。BFC提供了一个独立的环境（空间），HTML在这个环境中会按照一定的规则进行布局。\nBFC对布局的影响 # 也就是BFC规则：\nBFC内部的块元素会在垂直方向一个接一个的排列 处于同一个BFC内的元素外边距会重叠 计算BFC高度时，它包含的所有元素都要算进去，连浮动元素也算 BFC容器内的元素不受容器外部元素的影响，外部元素也不受BFC内部元素影响 外部的浮动元素不会叠加到BFC上 下面用几个例子解释一下这些规则吧。 BFC中的常规流 # \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .container { width: 500px; height: 500px; background-color: black; overflow: hidden; } .item { width: 100px; height: 100px; margin: 10px; background-color: red; } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; container是一个BFC容器，里面的item默认就是按照从上到下排列的。\n外边距重叠 # .item { width: 100px; height: 100px; margin: 10px; background-color: red; } .item:last-child { margin-top: 20px; } 可以看出，第二个item距离第一个item的外边距是10px，距离第三个item是20px，但其实三个item都设置了margin，因为处于同一个BFC中，所以元素间的外边距取最大值，而不是相加后的值。\nBFC的高度 # \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .container { width: 500px; background-color: black; /* overflow: hidden; */ } .item { width: 100px; height: 100px; margin: 10px; float: left; background-color: red; } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 我们不给容器设置高度，子元素设置一个float: left属性，最终显示的效果是这样 由于子元素脱离文档流造成容器高度坍塌，height: 0所以背景色没有显示，我们把注释掉的overflow: hidden;属性加回来，容器变成了BFC，背景色就显示出来了 这就是为什么说计算BFC的高度需要考虑所有的元素，包括浮动元素。\nBFC不受外部元素影响 # 前面提到在同一个BFC里，元素之间的外边距会重叠，那如果把另一个元素变成一个BFC的话，会是什么效果呢？\n\u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .container { width: 500px; background-color: black; overflow: hidden; } .item { width: 100px; height: 100px; margin: 10px; background-color: red; } .item:last-child { display: inline-block; margin-top: 20px; } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 第二个item变成了一个BFC，并且margin-top设为了20px，两个元素之间的边距变成了30px。\n浮动元素不会叠加到BFC上 # \u0026lt;style type=\u0026#34;text/css\u0026#34;\u0026gt; .container { width: 400px; background-color: black; } .item { width: 100px; height: 100px; } .item:first-child { float: left; background-color: red; } .item:last-child { width: 300px; background-color: green; /* display: flex; */ } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div class=\u0026#34;container\u0026#34;\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;item\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 子元素item进行左右布局，一个设置为float元素，一个固定宽度为300px，显示效果如下图 浮动元素和另一个元素重叠在一起了。\n现在我们把第二个元素被注释掉的display: flex;属性加回来，让它变成BFC再看下效果 两个元素相邻排列，谁也没妨碍谁。\nBFC触发条件 # 上面的例子已经有提到几个触发属性了：\n根元素或其它包含它的元素 内联块元素：具有display : inline-block;属性的元素 具有overflow属性，且值不为visible的块元素 弹性盒元素：display属性的值为flex或inline-flex 绝对定位元素：pisition属性值为absolute或fixed 浮动元素：具有float属性，且值不为none 表格单元格：display: table-cell 表格标题：display: table-caption display: flow-root column-span: all ","date":"22 十月 2022","permalink":"/posts/bfc/","section":"Posts","summary":"什么是BFC？问到这个问题无非就是让你答这几个点：BFC是什么，怎么触发BFC，BFC能干什么。几个例子让你彻底搞懂答案。","title":"大白话版：什么是BFC"},{"content":"遥想当初第一次用js写的功能组件就轮播图，在掘金看到大佬怎样一步步封装抽象轮播图，实在是太优雅了，终于体会到看人家敲代码是种享受的感觉。\n初步实现 # 大佬是以京东商城的轮播图为例子实现的。 我特意去淘宝首页看了一眼，过去我的轮播图效果和淘宝的是一样的，都是滚动切换， 而京东的是设置透明度实现切换效果。\n图片切换 # 首先是html代码，经典的ul标签\n\u0026lt;div id=\u0026#34;my-slider\u0026#34; class=\u0026#34;slider-list\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li class=\u0026#34;slider-list__item--selected\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://p5.ssl.qhimg.com/t0119c74624763dd070.png\u0026#34;/\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;slider-list__item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://p4.ssl.qhimg.com/t01adbe3351db853eb3.jpg\u0026#34;/\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;slider-list__item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://p2.ssl.qhimg.com/t01645cd5ba0c3b60cb.jpg\u0026#34;/\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;slider-list__item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://p4.ssl.qhimg.com/t01331ac159b58f5478.jpg\u0026#34;/\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; 然后加上css样式\n#my-slider{ position: relative; width: 790px; height: 340px; } .slider-list ul{ list-style-type:none; position: relative; width: 100%; height: 100%; padding: 0; margin: 0; } .slider-list__item, .slider-list__item--selected{ position: absolute; transition: opacity 1s; opacity: 0; text-align: center; } .slider-list__item--selected{ transition: opacity 1s; opacity: 1; } js代码控制轮播\nclass Slider { constructor(id) { // 轮播图的dom容器 this.container = document.getElementById(id) // 轮播图中的所有轮播对象dom this.items = this.container.querySelectorAll(\u0026#39;.slider-list__item--selected, .slider-list__item\u0026#39;) } // 获取当前选中的轮播对象 getSelectedItem() { const selected = this.container.querySelector(\u0026#39;.slider-list__item--selected\u0026#39;) return selected } // 获取当前选中的轮播对象的下角标 getSelectedItemIndex() { return Array.from(this.items).indexOf(this.getSelectedItem()) } // 滚动至指定下角标的图片 slideTo(inx) { const selected = this.getSelectedItem() if(selected) { selected.className = \u0026#39;slider-list__item\u0026#39; } const item = this.items[inx] if(item) { item.className = \u0026#39;slider-list__item--selected\u0026#39; } } // 滚动到下一张图 slideNext() { const currentInx = this.getSelectedItemIndex() // 通过取余的方式获得下长图的下角标 const nextInx = (currentInx + 1) % this.items.length this.slideTo(nextInx) } // 滚动到上一张图 slidePrevious() { const currentInx = this.getSelectedItemIndex() // 为了防止下角标为负的，前面再加一个所有轮播对象的总数再取余 const previousInx = (this.items.length + currentInx - 1) % this.items.length this.slideTo(previousInx) } } // 调用构造函数，每2s切换一次图片 const mySlider = new Slider(\u0026#39;my-slider\u0026#39;) setInterval(() =\u0026gt; { mySlider.slideNext() }, 2000) 写了一个构造函数，设计的方法遵守指责单一和可扩展性的原则，定义了几个方法，简单明了。 这样图片就能自动切换了，但功能完整的轮播图上还应该有两个小组件\n控制流 # 下方的指示标和鼠标移入后的左右切换按钮。\n\u0026lt;div id=\u0026#34;my-slider\u0026#34; class=\u0026#34;slider-list\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li class=\u0026#34;slider-list__item--selected\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://p5.ssl.qhimg.com/t0119c74624763dd070.png\u0026#34;/\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;slider-list__item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://p4.ssl.qhimg.com/t01adbe3351db853eb3.jpg\u0026#34;/\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;slider-list__item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://p2.ssl.qhimg.com/t01645cd5ba0c3b60cb.jpg\u0026#34;/\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;slider-list__item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://p4.ssl.qhimg.com/t01331ac159b58f5478.jpg\u0026#34;/\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;a class=\u0026#34;slide-list__next\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;a class=\u0026#34;slide-list__previous\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;div class=\u0026#34;slide-list__control\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;slide-list__control-buttons--selected\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;slide-list__control-buttons\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;slide-list__control-buttons\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;slide-list__control-buttons\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; js代码主要的变化是加了两个方法控制轮播的开始和结束\nstart() { this.stop() this._timer = setInterval(() =\u0026gt; { this.slideNext() }, this.cycle) } stop() { clearInterval(this._timer) } 原方法里只有一个地方发生了改变\nslideTo(inx) { const selected = this.getSelectedItem() if(selected) { selected.className = \u0026#39;slider-list__item\u0026#39; } const item = this.items[inx] if(item) { item.className = \u0026#39;slider-list__item--selected\u0026#39; } // 设置自定义事件，方便监听图片切换 const detail = {index: inx} const event = new CustomEvent(\u0026#39;slide\u0026#39;, {bubbles:true, detail}) this.container.dispatchEvent(event) } 之所以用自定义事件是为了解耦。 然后是新添加的组件控制流相关代码\nconstructor(id, cycle = 3000) { this.container = document.getElementById(id) this.items = this.container.querySelectorAll(\u0026#39;.slider-list__item--selected, .slider-list__item\u0026#39;) this.cycle = cycle const controller = this.container.querySelector(\u0026#39;.slide-list__control\u0026#39;) if (controller) { const buttons = controller.querySelectorAll(\u0026#39;.slide-list__control-buttons--selected, .slide-list__control-buttons\u0026#39;) controller.addEventListener(\u0026#39;mouseover\u0026#39;, evt =\u0026gt; { const idx = Array.from(buttons).indexOf(evt.target) if (idx \u0026gt;= 0) { this.slideTo(idx) this.stop() } }) controller.addEventListener(\u0026#39;moseout\u0026#39;, () =\u0026gt; { this.start() }) this.container.addEventListener(\u0026#39;slide\u0026#39;, evt =\u0026gt; { const idx = evt.detail.index const selected = controller.querySelector(\u0026#39;.slide-list__control-buttons--selected\u0026#39;); if(selected) selected.className = \u0026#39;slide-list__control-buttons\u0026#39;; buttons[idx].className = \u0026#39;slide-list__control-buttons--selected\u0026#39;; }) } const previous = this.container.querySelector(\u0026#39;.slide-list__previous\u0026#39;) if(previous) { previous.addEventListener(\u0026#39;click\u0026#39;, evt =\u0026gt; { this.stop() this.slidePrevious() this.start() evt.preventDefault() }) } const next = this.container.querySelector(\u0026#39;.slide-list__next\u0026#39;) if (next) { next.addEventListener(\u0026#39;click\u0026#39;, evt =\u0026gt; { this.stop() this.slideNext() this.start() evt.preventDefault() }) } } 都是监听组件上的鼠标移入移出事件和点击事件，实现图片的切换以及组件样式的变化。 以上，一个轮播图就实现了。 但对于这个组件来说，添加和删除控制按钮需要修改的代码太多了，对于后期扩展和维护来说体验都很不好， 接下来就要重构代码，让它更易扩展。\n重构 # 将之前添加的控制按钮都插件化。\n插件化 # 第一步是把控制按钮相关的方法都从构造函数中抽出来\nfunction pluginController(slider){ const controller = slider.container.querySelector(\u0026#39;.slide-list__control\u0026#39;); if(controller){ const buttons = controller.querySelectorAll(\u0026#39;.slide-list__control-buttons, .slide-list__control-buttons--selected\u0026#39;); controller.addEventListener(\u0026#39;mouseover\u0026#39;, evt=\u0026gt;{ const idx = Array.from(buttons).indexOf(evt.target); if(idx \u0026gt;= 0){ slider.slideTo(idx); slider.stop(); } }); controller.addEventListener(\u0026#39;mouseout\u0026#39;, evt=\u0026gt;{ slider.start(); }); slider.addEventListener(\u0026#39;slide\u0026#39;, evt =\u0026gt; { const idx = evt.detail.index const selected = controller.querySelector(\u0026#39;.slide-list__control-buttons--selected\u0026#39;); if(selected) selected.className = \u0026#39;slide-list__control-buttons\u0026#39;; buttons[idx].className = \u0026#39;slide-list__control-buttons--selected\u0026#39;; }); } } function pluginPrevious(slider){ const previous = slider.container.querySelector(\u0026#39;.slide-list__previous\u0026#39;); if(previous){ previous.addEventListener(\u0026#39;click\u0026#39;, evt =\u0026gt; { slider.stop(); slider.slidePrevious(); slider.start(); evt.preventDefault(); }); } } function pluginNext(slider){ const next = slider.container.querySelector(\u0026#39;.slide-list__next\u0026#39;); if(next){ next.addEventListener(\u0026#39;click\u0026#39;, evt =\u0026gt; { slider.stop(); slider.slideNext(); slider.start(); evt.preventDefault(); }); } } 插件和组件之间，通过依赖注入的方式建立联系，也就是在构造函数中写一个注册插件的方法\nclass Slider { constructor(id, cycle = 3000) { this.container = document.getElementById(id); this.items = this.container.querySelectorAll(\u0026#39;.slider-list__item, .slider-list__item--selected\u0026#39;); this.cycle = cycle; } registerPlugins(...pulgins) { plugins.forEach(plugin =\u0026gt; plugin(this)) } // ...其它方法 } 调用时\nconst slider = new Slider(\u0026#39;my-slider\u0026#39;) slider.registerPlugins(pluginController, pluginPrevious, pluginNext) slider.start() 如果后续需要添加新的插件，就无需修改构造函数，直接在外部写函数，然后调用registerPlugins方法注册到组件上就好了。 但仍然有个问题，那就是修改组件不仅需要修改js代码，还需要改动html代码，还可以继续封装，做到扩展时只需要添加删除js部分的代码。\n模板化 # 将html那部分模板化，那么实际调用组件时的html代码就只剩一行\n\u0026lt;div id=\u0026#34;my-slider\u0026#34; class=\u0026#34;slider-list\u0026#34; /\u0026gt; js代码部分，既然要模板化html，那就是动态生成html，给构造函数传入的参数会多一个images，添加render方法生成dom，注册插件的方法也会有所不同。\nclass Slider{ constructor(id, opts = {images:[], cycle: 3000}){ this.container = document.getElementById(id); this.options = opts; // 动态生成html内容 this.container.innerHTML = this.render(); this.items = this.container.querySelectorAll(\u0026#39;.slider-list__item, .slider-list__item--selected\u0026#39;); this.cycle = opts.cycle || 3000; // 动态生成dom后需要调用slideTo方法，设置选中的第一张图片，否则直到调用下一个slideTo方法后，会一直是空白的 this.slideTo(0); } render(){ const images = this.options.images; // 根据传入的图片自动生成html代码 const content = images.map(image =\u0026gt; ` \u0026lt;li class=\u0026#34;slider-list__item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;${image}\u0026#34;/\u0026gt; \u0026lt;/li\u0026gt; `.trim()); return `\u0026lt;ul\u0026gt;${content.join(\u0026#39;\u0026#39;)}\u0026lt;/ul\u0026gt;`; } registerPlugins(...plugins){ plugins.forEach(plugin =\u0026gt; { const pluginContainer = document.createElement(\u0026#39;div\u0026#39;); pluginContainer.className = \u0026#39;.slider-list__plugin\u0026#39;; pluginContainer.innerHTML = plugin.render(this.options.images); this.container.appendChild(pluginContainer); plugin.action(this); }); } // ...其它方法 } 插件注册的方法变了，现在的设计是，传入的插件必须有两个方法：render和action\nconst pluginController = { // 需要根据传入组件的图片生成相应数量的控件 render(images){ return ` \u0026lt;div class=\u0026#34;slide-list__control\u0026#34;\u0026gt; ${images.map((image, i) =\u0026gt; ` \u0026lt;span class=\u0026#34;slide-list__control-buttons${i===0?\u0026#39;--selected\u0026#39;:\u0026#39;\u0026#39;}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; `).join(\u0026#39;\u0026#39;)} \u0026lt;/div\u0026gt; `.trim(); }, action(slider){ const controller = slider.container.querySelector(\u0026#39;.slide-list__control\u0026#39;); if(controller){ const buttons = controller.querySelectorAll(\u0026#39;.slide-list__control-buttons, .slide-list__control-buttons--selected\u0026#39;); controller.addEventListener(\u0026#39;mouseover\u0026#39;, evt =\u0026gt; { const idx = Array.from(buttons).indexOf(evt.target); if(idx \u0026gt;= 0){ slider.slideTo(idx); slider.stop(); } }); controller.addEventListener(\u0026#39;mouseout\u0026#39;, evt =\u0026gt; { slider.start(); }); slider.addEventListener(\u0026#39;slide\u0026#39;, evt =\u0026gt; { const idx = evt.detail.index const selected = controller.querySelector(\u0026#39;.slide-list__control-buttons--selected\u0026#39;); if(selected) selected.className = \u0026#39;slide-list__control-buttons\u0026#39;; buttons[idx].className = \u0026#39;slide-list__control-buttons--selected\u0026#39;; }); } } }; const pluginPrevious = { render(){ return `\u0026lt;a class=\u0026#34;slide-list__previous\u0026#34;\u0026gt;\u0026lt;/a\u0026gt;`; }, action(slider){ const previous = slider.container.querySelector(\u0026#39;.slide-list__previous\u0026#39;); if(previous){ previous.addEventListener(\u0026#39;click\u0026#39;, evt =\u0026gt; { slider.stop(); slider.slidePrevious(); slider.start(); evt.preventDefault(); }); } } }; const pluginNext = { render(){ return `\u0026lt;a class=\u0026#34;slide-list__next\u0026#34;\u0026gt;\u0026lt;/a\u0026gt;`; }, action(slider){ const previous = slider.container.querySelector(\u0026#39;.slide-list__next\u0026#39;); if(previous){ previous.addEventListener(\u0026#39;click\u0026#39;, evt =\u0026gt; { slider.stop(); slider.slideNext(); slider.start(); evt.preventDefault(); }); } } }; 插件不再是函数，而是个对象，值是个函数。 调用方法：\nconst slider = new Slider(\u0026#39;my-slider\u0026#39;, {images: [\u0026#39;https://p5.ssl.qhimg.com/t0119c74624763dd070.png\u0026#39;, \u0026#39;https://p4.ssl.qhimg.com/t01adbe3351db853eb3.jpg\u0026#39;, \u0026#39;https://p2.ssl.qhimg.com/t01645cd5ba0c3b60cb.jpg\u0026#39;, \u0026#39;https://p4.ssl.qhimg.com/t01331ac159b58f5478.jpg\u0026#39;], cycle:3000}); slider.registerPlugins(pluginController, pluginPrevious, pluginNext); slider.start(); 如果是以前的我，能做到这里就已经很牛逼了，然后迫不及待地上线。 但对于大佬说，这并不是终点。\n抽象通用组件框架 # 由上图可以看出，通用组件的设计中包含两个方法:\nregisterPlugins(...plugins)：注册插件 render()：渲染html 抽象出来的通用组件代码如下：\nclass Component{ constructor(id, opts = {name, data:[]}){ this.container = document.getElementById(id); this.options = opts; this.container.innerHTML = this.render(opts.data); } registerPlugins(...plugins){ plugins.forEach(plugin =\u0026gt; { const pluginContainer = document.createElement(\u0026#39;div\u0026#39;); pluginContainer.className = `.${name}__plugin`; pluginContainer.innerHTML = plugin.render(this.options.data); this.container.appendChild(pluginContainer); plugin.action(this); }); } render(data) { /* abstract */ return \u0026#39;\u0026#39; } } Slider继承自Component\nclass Slider extends Component{ constructor(id, opts = {name: \u0026#39;slider-list\u0026#39;, data:[], cycle: 3000}){ super(id, opts); this.items = this.container.querySelectorAll(\u0026#39;.slider-list__item, .slider-list__item--selected\u0026#39;); this.cycle = opts.cycle || 3000; this.slideTo(0); } // 重写render函数 render(data){ const content = data.map(image =\u0026gt; ` \u0026lt;li class=\u0026#34;slider-list__item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;${image}\u0026#34;/\u0026gt; \u0026lt;/li\u0026gt; `.trim()); return `\u0026lt;ul\u0026gt;${content.join(\u0026#39;\u0026#39;)}\u0026lt;/ul\u0026gt;`; } // ...其它方法 } 上面的Component类已经是一个组件框架了，它支持定义一个组件和注册插件的功能。\n总结 # 根据上面几个步奏，我们已经完成了组件的插件化、模板化和抽象化。\n这个抽象出来的框架虽小，但对于日常业务来说完全够用了。\n但它并没有考虑到组件嵌套，这里直接将插件分离出来了。\n如果想要进阶完善，可以将插件作为子组件整合进框架里。\n另外，模板化这里只考虑到了html，如果要修改组件还要手动修改css，可以思考如何将css也进行模板化。\n","date":"21 十月 2022","permalink":"/posts/js/","section":"Posts","summary":"通过实现和封装一个轮播图组件，由浅入深地理解什么才是优秀的js代码。","title":"JS之组件封装"},{"content":"git体系 # 由上图可以看出，git主要由两部分组成，一个是远端仓库，一个是本地仓库。 本地仓库又由一下几个部分组成：\n工作区：就是我们平时写代码的地方，比如我最常用的就是vscode 暂存区：我们运行git add命令时，代码就会被推到暂存区，起到一个缓存的作用，同时也能帮Git在做diff的时候提高查找性能 本地分支：运行git commit命令后，代码就被提交到本地分支上了，可以在本地.git目录下的refs/heads目录中查看到本地的分支代码信息 远端分支本地副本：执行pull、fetch、push指令时都会往这里更新，它是远程仓库各分支数据在本地的一个副本，.git文件下的refs/remotes目录可以查看到具体信息 git工作流程 # 日常工作中，我们常用流程大概是这样：\n在github上建一个新的远程库，或者远程库中已经有数据了\ngit init # 这时本地还没有库，我们先用git init命令初始化一个git仓库\n现在远程、本地都有仓库了，但是二者没有任何关联，将他们联系起来有两种情况\ngit remote # 如果远程仓库是新建的，没有任何数据，我们需要使用git remote add origin xxx.git添加一个远程版本库到本地， 相应的git remote rm命令是删除远程版本库关联。\n然后使用git push -u origin master把当前仓库的master分支和远端仓库的master分支关联起来，这样后续我们push或者pull的时候就可以直接输git push/pull，而不是git push\\pull origin master。\ngit push后面的-u是什么意思 # 给git push加一个-u参数，其实就相当于给本地分支定义一个上游分支，让git知道当前操作的是哪条分支。 相当于同时执行了git push origin master和git branch --set-upstream master origin/master 如果一开始没有代入这个参数，直接运行git pull指令时，会出现以下报错 大概意思是没找到当前分支\ngit clone # 如果远程库已经有数据了，可以直接在本地库使用git clone xxx.git命令将远程库克隆到本地\n这时我们默认是在master分支上\n当我们在上面的命令行后添加参数git clone xxx.git -b branch时，会自动给我切换到branch分支上\ngit branch # 关于分支的操作有这些：\ngit branch：查看本地所有分支信息 git branch -r：查看远程仓库所有分支 git branch -a：查看本地和远程仓库所有分支 git checkout # 如果我们想以当前分支为基准创建一个新的本地分支并切换过去，可以使用git checkout -b branch1命令， 它其实是两个命令合并而成的：git branch branch1创建分支，git checkout branch1切换到该分支上。\ngit add # 当我们在工作区吭哧吭哧敲完代码，根据流程，我们得先把代码添加到暂存区，就需要用到git add命令了\n我们可以一个一个文件添加到暂存区：git add [filename1] [filename2] ... 或者把当前目录下所有文件改动都一口气添加到暂存区：git add . 又或者直接把仓库里所有文件改动都添加到暂存区：git add -A git commit # 然后我们就需要把代码推到本地分支上去了：git commit [filename1] ... -m [mesaage] 这个命令有两个参数：\n-m：后面跟的是本次提交的相关信息，可以简单地描述一下本次提交代码做了哪些改动，添加了什么功能 -a：对于已经被commit提交过的代码，这个命令相当于执行了git add -A，不需要另外再add一遍了； 对于没有被提交过的文件，还是需要add后才能被commit到本地分支上去 一般工作中更多的是使用git commit -m 'do sth'这个命令，也可以使用git commit -am命令，相当于同时执行了git add和git commit。\ngit rm # 有添加就有删除，当我们不小心把不需要提交的文件提交到本地仓库了，可以使用git rm [filename]将其删除。\ngit rm -r dist可以直接删除一个目录。\ngit push # 接下来就要正是把代码推送到远程仓库里去了。\n如果我们至始至终都在master分支上工作，并且之前初始化本地仓库时运行了git push -u origin master命令，现在只需要输入git push指令就ok了。\n如果我们是要将本地创建的分支推送到远端，就需要使用git push --set-upstream origin branch1将分支推上去并关联起来。\n有没有觉得这行代码很熟悉？上面git pull的报错图推荐的指令是git branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; test，就是将本地分支和远程分支关联起来。\n如果远程仓库中已经有了这个分支时，本地代码没有和远程代码冲突的情况下会直接将本地改动提交上去；\n如果出现冲突，就会提示你先把远端分支中的代码pull下来解决冲突，然后再推上去。\ngit pull # 当本地分支和远端分支已经建立联系了，我们只需要git pull就能把代码拉到本地，但如果出现上面的情况，\n两端没能建立联系，就需要使用git pull origin branch1拉取指定的远端分支到本地分支。\n冲突解决后再运行git push --set-upstream origin branch1。\ngit fetch # 当远端仓库对应分支的代码有了新的变更，而当前工作区的代码还没有修改完成，就可使用git fetch将远端代码先拉到本地仓库\ngit merge # 等本地代码写完并提交到本地仓库了，需要合并一下远端分支的更改，就可使用git merge origin/[branchname]。 也可以将指定分支的代码合并到当前分支：\ngit checkout master切换到master分支，git pull拉取最新代码 切回开发分支，执行git merge master合并master代码到开发分支中 和上面的代码实现的效果是一样的，只是所有修改都在开发分支里了，master分支上并没有我们提交的修改。 等修改测试后没有问题可以上线了，再切换到master分支，用git merge origin/[branch1]把分支合并到主分支上，然后git push origin master git log # 提交代码后都可以通过这个指令看到提交记录，这个主要是用来进行代码版本的回滚等操作的\ngit reset # 这个指令后面跟着一个参数和一个版本信息。 在你查看git log的时候，会有一行信息大概长这样\ncommit e55c4d273141edff401cbc6642fe21e14681c258 (HEAD -\u0026gt; branch1, origin/branch1) commit后面这一串数字就是这个版本信息，一般都很长，我们可以只复制前7位。 git reset有三个参数：\n--soft：如果你已经将改动commit到本地仓库，git reset --soft e55c4d2可以让本地仓库的内容回到e55c4d2这一次提交，但暂存区和工作区的内容还在 --mixed：默认参数，暂存区的内容也会回到指定回滚的版本，工作区的改动还在 --hard：直接连工作区的代码都回滚到指定版本，之前所有改动都没有了 git relog # 当你reset之后，在看git log会发现，回滚版本后的所有提交历史都不见了，最新提交记录就是你此时回滚到的版本。 但你发现之后的代码提交中有一部分你依然需要，就可以使用git relog看到所有的操作记录了，然后就可以CV需要的代码了。\ngit revert # 这是一个温和版的reset。 reset相当于时间穿越，让你穿越到指定的提交，所以git log看不到reset版本后的记录； 而resvet是产生一个新的提交，把你改动的代码都恢复到指定版本的样子。\ngit cherry-pick # 一个不常用，但可以救人于水火的功能。 我是小白的时候，在修改代码时总是会忘记切换分支，直接就在master上改了，如果代码已经被commit到本地仓库，就可以git log查看提交记录，复制本应该在分支上提交的commitId，如果有多个提交就全都复制下来，然后切换到需要修改的分支上，使用git cherry-pick master commitId1 commitId2 ...指令。 之后别忘了在master分支上用reset或者revert回滚一下代码。\ngit tag # 如果一个项目一直有人维护、更新迭代，就会给它打上标签标注版本。 标签有两种：轻量标签和附注标签\n轻量标签 # 创建指令：git tag v1.0.0 一旦创建了标签，就基于当前分支创建了一个不可变的分支，当你切换到这个分支并做任何修改并提交，都无法在分支历史中找到记录，它会帮你生成一个独立提交，commitId可以在如图左下角查看到 你可以通过commitId切换到本次提交，如果需要保留当前提交，可以使用git switch -c \u0026lt;new-branch-name\u0026gt;创建一个新分支， 否则直接git switch -丢弃这次提交。\n附注标签 # 创建指令：git tag -a v1.0.1 -m \u0026quot;发布正式版 1.0.1\u0026quot; 比轻量标签多了两个参数，同时也能保留更多信息，它是存储在Git数据库中的一个完整对象。 git show可以看到标签信息。\n推送标签 # git push origin tagName 创建完标签就能把它推送到远端了。\n其它命令 # git tag：查看标签 git tag -l v1.0.1：筛选标签 git tag -d v1.0.1：删除本地标签 git push origin --delete v1.0.2：删除远程标签 git rebase # rebase常常会和merge作比较，从字面意义上看，rebase就是改变基准库。 假设有两个分支，一个master，一个feature 由上图可以看出feature是基于master分支的B节点创建的，之后，在master分支上有一个新提交M，而feature上有两个新提交，C和D。 当我们输入以下指令\ngit checkout feature git rebase master 提交节点就变成了这样 feature的基底变成了M节点，并且feature上的提交合并到了新基底后面。 如果在rebase时，master分支上没有新提交，那么就不存在换基，效果跟merge就一样了，只是merge指令会多一条记录merge操作的提交记录。 实际工作中建议还是使用merge，因为日志会把每一次提交都记录下来，而rebase会让日志呈线性显示，无法得知最初支线是从哪个节点拉取出来的。\nstash # 最后说一个特殊区域，git本地除了工作区、暂存区和本地分支外，还有个储存区。 一般我使用它的场景是， 在一个分支工作了一会，突然需要切换到另一个分支上去，又不好把未完成的代码推上去， 就先git stash把变更保存在本地， 等另一个分支的问题解决之后，切换到之前的分支git stash pop把最新stash的更改加回来。 但并不是很推荐这样用，因为一旦忘记就麻烦了。\n常用命令 # git stash save 'xxx'：存储变更，如果直接git stash会自动分配储存记录标记 git stash list：查看储存区的所有提交列表 git stash pop：弹出并引用最近一次存储区的代码提交 git stash drop stash@{n}：删除某次储存记录 git stash clear：清除所有stash信息 参考文章 # 《Git体系介绍+常用命令及其应用场景》 《git中push -u是什么意思》 《git rebase详解（图解+最简单示例，一次就懂）》 ","date":"16 十月 2022","permalink":"/posts/git/","section":"Posts","summary":"大致介绍Git的构成和工作流程。在流程介绍和部分场景介绍中穿插对Git指令的讲解。","title":"Git查漏补缺"},{"content":"为什么选择Hugo # Hugo是由Go语言实现的，无需搭建复杂的运行环境，几行命令行就能快速生产一个静态网站。 官网提供了多种风格的免费主题，还有优秀网站展示，满足了个人的自定义需求。\n如何搭建 # 就像前面所说，只需要几行命令行就能够搭建出一个属于自己的博客。\n安装Hugo # 首先得安装Hugo(git下载)。 Mac可直接使用brew install hugo安装。 windows系统安装完Hugo后需要配置环境变量，在命令行中输入hugo version来测试是否安装成功。\n生成站点 # 输入命令行\nhugo new [网站名称] [本地存放目录地址] Mac就在想要创建博客的根目录下输入指令\nhugo new site [名称] 就可在你想要的目录中生成网站文件。\n创建文章 # hugo new post/first.md 输入以上命令行就可在post目录下生成一个名为first的markdown格式文件。 打开文件大概长这样：\n--- date: \u0026#34;2015-10-25T08:36:54-07:00\u0026#34; title: \u0026#34;first\u0026#34; draft: true # draft为true表示当前文章是草稿 --- ###文章正文在这 设置主题 # 在官网提供的主题中选择自己心仪的主题，一般点进主题页都会有下载和配置文档，万变不离其宗。 当前我使用的主题叫congo，使用的是git submodule方式下载的：\ncd [网站文件根目录] git init git submodule add -b stable https://github.com/jpanther/congo.git themes/congo 命令行中的地址是主题在git上的地址，后面跟着的是主题存放目录和主题文件名。 当然还有其它的下载方式，可以参考congo文档。\n本地运行 # 然后我们就可以本地启动服务进行调试了：\nhugo server --theme=congo --buildDrafts theme=congo是设置主题，buildDrafts是指生成草稿，还记得前面文章中有个参数draft: true吗？如果没有这个命令，是看不到草稿文章的，需要将draft设为false才能显示在博客上。 然后就可以在浏览器打开http://localhost:1313预览本地博客了。\n关于这块有一个坑 # 由于主题文件都是通过git submodule添加进来的子模块，当我从git上clone博客项目后再hugo server本地运行会报错，这时能看到主题文件夹里是空的，因为主题文件不会自动下载下来，只要git submodule update --recursive重新下载主题就好了。\n部署到服务器 # 作为一个程序员，能免费的东西绝不花钱。这里我们就能用github提供的免费服务器来部署我们的博客，首先得在github上建一个新的库，库的名称设为[github用户名(全小写)].github.io.git。 在网站存放的根目录执行命令：\nhugo --theme=congo --baseUrl=\u0026#34;https://[github用户名(全小写)].github.io/\u0026#34; 后面的地址就是访问在线博客的地址。 命令行运行后，根目录下会有个public文件夹，把这个文件夹里的内容推到刚刚创建的github库里就完成部署了。\ncd public git init git remote add origin [github库的完整地址] git add -. git commit -m \u0026#39;fist commit\u0026#39; git push -u origin master 文章更新 # 后续需要更新博文时，输入hugo指令，博客项目文件夹里的新文章就会发布到public文件夹内，再将public推到git库里就OK了。\n","date":"15 十月 2022","permalink":"/posts/first-blog/","section":"Posts","summary":"自从typora收费之后，就没有找到一个用着存粹又得心应手的笔记软件了，干脆自己搞一个博客玩玩。本文简单记录了使用Hugo建博的过程。","title":"关于个人博客的建成"},{"content":"","date":"15 十月 2022","permalink":"/about/","section":"HeleneWoods的主页","summary":"","title":"关于我"},{"content":"","date":"1 一月 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 一月 0001","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]