[{"content":"","date":"21 十月 2022","permalink":"/","section":"HeleneWoods","summary":"","title":"HeleneWoods"},{"content":"遥想当初第一次用js写的功能组件就轮播图，在掘金看到大佬怎样一步步封装抽象轮播图，实在是太优雅了，终于体会到看人家敲代码是种享受的感觉。\n初步实现 # 大佬是以京东商城的轮播图为例子实现的。 我特意去淘宝首页看了一眼，过去我的轮播图效果和淘宝的是一样的，都是滚动切换， 而京东的是设置透明度实现切换效果。\n图片切换 # 首先是html代码，经典的ul标签\n\u0026lt;div id=\u0026#34;my-slider\u0026#34; class=\u0026#34;slider-list\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li class=\u0026#34;slider-list__item--selected\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://p5.ssl.qhimg.com/t0119c74624763dd070.png\u0026#34;/\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;slider-list__item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://p4.ssl.qhimg.com/t01adbe3351db853eb3.jpg\u0026#34;/\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;slider-list__item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://p2.ssl.qhimg.com/t01645cd5ba0c3b60cb.jpg\u0026#34;/\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;slider-list__item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://p4.ssl.qhimg.com/t01331ac159b58f5478.jpg\u0026#34;/\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; 然后加上css样式\n#my-slider{ position: relative; width: 790px; height: 340px; } .slider-list ul{ list-style-type:none; position: relative; width: 100%; height: 100%; padding: 0; margin: 0; } .slider-list__item, .slider-list__item--selected{ position: absolute; transition: opacity 1s; opacity: 0; text-align: center; } .slider-list__item--selected{ transition: opacity 1s; opacity: 1; } js代码控制轮播\nclass Slider { constructor(id) { // 轮播图的dom容器 this.container = document.getElementById(id) // 轮播图中的所有轮播对象dom this.items = this.container.querySelectorAll(\u0026#39;.slider-list__item--selected, .slider-list__item\u0026#39;) } // 获取当前选中的轮播对象 getSelectedItem() { const selected = this.container.querySelector(\u0026#39;.slider-list__item--selected\u0026#39;) return selected } // 获取当前选中的轮播对象的下角标 getSelectedItemIndex() { return Array.from(this.items).indexOf(this.getSelectedItem()) } // 滚动至指定下角标的图片 slideTo(inx) { const selected = this.getSelectedItem() if(selected) { selected.className = \u0026#39;slider-list__item\u0026#39; } const item = this.items[inx] if(item) { item.className = \u0026#39;slider-list__item--selected\u0026#39; } } // 滚动到下一张图 slideNext() { const currentInx = this.getSelectedItemIndex() // 通过取余的方式获得下长图的下角标 const nextInx = (currentInx + 1) % this.items.length this.slideTo(nextInx) } // 滚动到上一张图 slidePrevious() { const currentInx = this.getSelectedItemIndex() // 为了防止下角标为负的，前面再加一个所有轮播对象的总数再取余 const previousInx = (this.items.length + currentInx - 1) % this.items.length this.slideTo(previousInx) } } // 调用构造函数，每2s切换一次图片 const mySlider = new Slider(\u0026#39;my-slider\u0026#39;) setInterval(() =\u0026gt; { mySlider.slideNext() }, 2000) 写了一个构造函数，设计的方法遵守指责单一和可扩展性的原则，定义了几个方法，简单明了。 这样图片就能自动切换了，但功能完整的轮播图上还应该有两个小组件\n控制流 # 下方的指示标和鼠标移入后的左右切换按钮。\n\u0026lt;div id=\u0026#34;my-slider\u0026#34; class=\u0026#34;slider-list\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li class=\u0026#34;slider-list__item--selected\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://p5.ssl.qhimg.com/t0119c74624763dd070.png\u0026#34;/\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;slider-list__item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://p4.ssl.qhimg.com/t01adbe3351db853eb3.jpg\u0026#34;/\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;slider-list__item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://p2.ssl.qhimg.com/t01645cd5ba0c3b60cb.jpg\u0026#34;/\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;li class=\u0026#34;slider-list__item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;https://p4.ssl.qhimg.com/t01331ac159b58f5478.jpg\u0026#34;/\u0026gt; \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;a class=\u0026#34;slide-list__next\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;a class=\u0026#34;slide-list__previous\u0026#34;\u0026gt;\u0026lt;/a\u0026gt; \u0026lt;div class=\u0026#34;slide-list__control\u0026#34;\u0026gt; \u0026lt;span class=\u0026#34;slide-list__control-buttons--selected\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;slide-list__control-buttons\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;slide-list__control-buttons\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;span class=\u0026#34;slide-list__control-buttons\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; js代码主要的变化是加了两个方法控制轮播的开始和结束\nstart() { this.stop() this._timer = setInterval(() =\u0026gt; { this.slideNext() }, this.cycle) } stop() { clearInterval(this._timer) } 原方法里只有一个地方发生了改变\nslideTo(inx) { const selected = this.getSelectedItem() if(selected) { selected.className = \u0026#39;slider-list__item\u0026#39; } const item = this.items[inx] if(item) { item.className = \u0026#39;slider-list__item--selected\u0026#39; } // 设置自定义事件，方便监听图片切换 const detail = {index: inx} const event = new CustomEvent(\u0026#39;slide\u0026#39;, {bubbles:true, detail}) this.container.dispatchEvent(event) } 之所以用自定义事件是为了解耦。 然后是新添加的组件控制流相关代码\nconstructor(id, cycle = 3000) { this.container = document.getElementById(id) this.items = this.container.querySelectorAll(\u0026#39;.slider-list__item--selected, .slider-list__item\u0026#39;) this.cycle = cycle const controller = this.container.querySelector(\u0026#39;.slide-list__control\u0026#39;) if (controller) { const buttons = controller.querySelectorAll(\u0026#39;.slide-list__control-buttons--selected, .slide-list__control-buttons\u0026#39;) controller.addEventListener(\u0026#39;mouseover\u0026#39;, evt =\u0026gt; { const idx = Array.from(buttons).indexOf(evt.target) if (idx \u0026gt;= 0) { this.slideTo(idx) this.stop() } }) controller.addEventListener(\u0026#39;moseout\u0026#39;, () =\u0026gt; { this.start() }) this.container.addEventListener(\u0026#39;slide\u0026#39;, evt =\u0026gt; { const idx = evt.detail.index const selected = controller.querySelector(\u0026#39;.slide-list__control-buttons--selected\u0026#39;); if(selected) selected.className = \u0026#39;slide-list__control-buttons\u0026#39;; buttons[idx].className = \u0026#39;slide-list__control-buttons--selected\u0026#39;; }) } const previous = this.container.querySelector(\u0026#39;.slide-list__previous\u0026#39;) if(previous) { previous.addEventListener(\u0026#39;click\u0026#39;, evt =\u0026gt; { this.stop() this.slidePrevious() this.start() evt.preventDefault() }) } const next = this.container.querySelector(\u0026#39;.slide-list__next\u0026#39;) if (next) { next.addEventListener(\u0026#39;click\u0026#39;, evt =\u0026gt; { this.stop() this.slideNext() this.start() evt.preventDefault() }) } } 都是监听组件上的鼠标移入移出事件和点击事件，实现图片的切换以及组件样式的变化。 以上，一个轮播图就实现了。 但对于这个组件来说，添加和删除控制按钮需要修改的代码太多了，对于后期扩展和维护来说体验都很不好， 接下来就要重构代码，让它更易扩展。\n重构 # 将之前添加的控制按钮都插件化。\n插件化 # 第一步是把控制按钮相关的方法都从构造函数中抽出来\nfunction pluginController(slider){ const controller = slider.container.querySelector(\u0026#39;.slide-list__control\u0026#39;); if(controller){ const buttons = controller.querySelectorAll(\u0026#39;.slide-list__control-buttons, .slide-list__control-buttons--selected\u0026#39;); controller.addEventListener(\u0026#39;mouseover\u0026#39;, evt=\u0026gt;{ const idx = Array.from(buttons).indexOf(evt.target); if(idx \u0026gt;= 0){ slider.slideTo(idx); slider.stop(); } }); controller.addEventListener(\u0026#39;mouseout\u0026#39;, evt=\u0026gt;{ slider.start(); }); slider.addEventListener(\u0026#39;slide\u0026#39;, evt =\u0026gt; { const idx = evt.detail.index const selected = controller.querySelector(\u0026#39;.slide-list__control-buttons--selected\u0026#39;); if(selected) selected.className = \u0026#39;slide-list__control-buttons\u0026#39;; buttons[idx].className = \u0026#39;slide-list__control-buttons--selected\u0026#39;; }); } } function pluginPrevious(slider){ const previous = slider.container.querySelector(\u0026#39;.slide-list__previous\u0026#39;); if(previous){ previous.addEventListener(\u0026#39;click\u0026#39;, evt =\u0026gt; { slider.stop(); slider.slidePrevious(); slider.start(); evt.preventDefault(); }); } } function pluginNext(slider){ const next = slider.container.querySelector(\u0026#39;.slide-list__next\u0026#39;); if(next){ next.addEventListener(\u0026#39;click\u0026#39;, evt =\u0026gt; { slider.stop(); slider.slideNext(); slider.start(); evt.preventDefault(); }); } } 插件和组件之间，通过依赖注入的方式建立联系，也就是在构造函数中写一个注册插件的方法\nclass Slider { constructor(id, cycle = 3000) { this.container = document.getElementById(id); this.items = this.container.querySelectorAll(\u0026#39;.slider-list__item, .slider-list__item--selected\u0026#39;); this.cycle = cycle; } registerPlugins(...pulgins) { plugins.forEach(plugin =\u0026gt; plugin(this)) } // ...其它方法 } 调用时\nconst slider = new Slider(\u0026#39;my-slider\u0026#39;) slider.registerPlugins(pluginController, pluginPrevious, pluginNext) slider.start() 如果后续需要添加新的插件，就无需修改构造函数，直接在外部写函数，然后调用registerPlugins方法注册到组件上就好了。 但仍然有个问题，那就是修改组件不仅需要修改js代码，还需要改动html代码，还可以继续封装，做到扩展时只需要添加删除js部分的代码。\n模板化 # 将html那部分模板化，那么实际调用组件时的html代码就只剩一行\n\u0026lt;div id=\u0026#34;my-slider\u0026#34; class=\u0026#34;slider-list\u0026#34; /\u0026gt; js代码部分，既然要模板化html，那就是动态生成html，给构造函数传入的参数会多一个images，添加render方法生成dom，注册插件的方法也会有所不同。\nclass Slider{ constructor(id, opts = {images:[], cycle: 3000}){ this.container = document.getElementById(id); this.options = opts; // 动态生成html内容 this.container.innerHTML = this.render(); this.items = this.container.querySelectorAll(\u0026#39;.slider-list__item, .slider-list__item--selected\u0026#39;); this.cycle = opts.cycle || 3000; // 动态生成dom后需要调用slideTo方法，设置选中的第一张图片，否则直到调用下一个slideTo方法后，会一直是空白的 this.slideTo(0); } render(){ const images = this.options.images; // 根据传入的图片自动生成html代码 const content = images.map(image =\u0026gt; ` \u0026lt;li class=\u0026#34;slider-list__item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;${image}\u0026#34;/\u0026gt; \u0026lt;/li\u0026gt; `.trim()); return `\u0026lt;ul\u0026gt;${content.join(\u0026#39;\u0026#39;)}\u0026lt;/ul\u0026gt;`; } registerPlugins(...plugins){ plugins.forEach(plugin =\u0026gt; { const pluginContainer = document.createElement(\u0026#39;div\u0026#39;); pluginContainer.className = \u0026#39;.slider-list__plugin\u0026#39;; pluginContainer.innerHTML = plugin.render(this.options.images); this.container.appendChild(pluginContainer); plugin.action(this); }); } // ...其它方法 } 插件注册的方法变了，现在的设计是，传入的插件必须有两个方法：render和action\nconst pluginController = { // 需要根据传入组件的图片生成相应数量的控件 render(images){ return ` \u0026lt;div class=\u0026#34;slide-list__control\u0026#34;\u0026gt; ${images.map((image, i) =\u0026gt; ` \u0026lt;span class=\u0026#34;slide-list__control-buttons${i===0?\u0026#39;--selected\u0026#39;:\u0026#39;\u0026#39;}\u0026#34;\u0026gt;\u0026lt;/span\u0026gt; `).join(\u0026#39;\u0026#39;)} \u0026lt;/div\u0026gt; `.trim(); }, action(slider){ const controller = slider.container.querySelector(\u0026#39;.slide-list__control\u0026#39;); if(controller){ const buttons = controller.querySelectorAll(\u0026#39;.slide-list__control-buttons, .slide-list__control-buttons--selected\u0026#39;); controller.addEventListener(\u0026#39;mouseover\u0026#39;, evt =\u0026gt; { const idx = Array.from(buttons).indexOf(evt.target); if(idx \u0026gt;= 0){ slider.slideTo(idx); slider.stop(); } }); controller.addEventListener(\u0026#39;mouseout\u0026#39;, evt =\u0026gt; { slider.start(); }); slider.addEventListener(\u0026#39;slide\u0026#39;, evt =\u0026gt; { const idx = evt.detail.index const selected = controller.querySelector(\u0026#39;.slide-list__control-buttons--selected\u0026#39;); if(selected) selected.className = \u0026#39;slide-list__control-buttons\u0026#39;; buttons[idx].className = \u0026#39;slide-list__control-buttons--selected\u0026#39;; }); } } }; const pluginPrevious = { render(){ return `\u0026lt;a class=\u0026#34;slide-list__previous\u0026#34;\u0026gt;\u0026lt;/a\u0026gt;`; }, action(slider){ const previous = slider.container.querySelector(\u0026#39;.slide-list__previous\u0026#39;); if(previous){ previous.addEventListener(\u0026#39;click\u0026#39;, evt =\u0026gt; { slider.stop(); slider.slidePrevious(); slider.start(); evt.preventDefault(); }); } } }; const pluginNext = { render(){ return `\u0026lt;a class=\u0026#34;slide-list__next\u0026#34;\u0026gt;\u0026lt;/a\u0026gt;`; }, action(slider){ const previous = slider.container.querySelector(\u0026#39;.slide-list__next\u0026#39;); if(previous){ previous.addEventListener(\u0026#39;click\u0026#39;, evt =\u0026gt; { slider.stop(); slider.slideNext(); slider.start(); evt.preventDefault(); }); } } }; 插件不再是函数，而是个对象，值是个函数。 调用方法：\nconst slider = new Slider(\u0026#39;my-slider\u0026#39;, {images: [\u0026#39;https://p5.ssl.qhimg.com/t0119c74624763dd070.png\u0026#39;, \u0026#39;https://p4.ssl.qhimg.com/t01adbe3351db853eb3.jpg\u0026#39;, \u0026#39;https://p2.ssl.qhimg.com/t01645cd5ba0c3b60cb.jpg\u0026#39;, \u0026#39;https://p4.ssl.qhimg.com/t01331ac159b58f5478.jpg\u0026#39;], cycle:3000}); slider.registerPlugins(pluginController, pluginPrevious, pluginNext); slider.start(); 如果是以前的我，能做到这里就已经很牛逼了，然后迫不及待地上线。 但对于大佬说，这并不是终点。\n抽象通用组件框架 # 由上图可以看出，通用组件的设计中包含两个方法:\nregisterPlugins(...plugins)：注册插件 render()：渲染html 抽象出来的通用组件代码如下：\nclass Component{ constructor(id, opts = {name, data:[]}){ this.container = document.getElementById(id); this.options = opts; this.container.innerHTML = this.render(opts.data); } registerPlugins(...plugins){ plugins.forEach(plugin =\u0026gt; { const pluginContainer = document.createElement(\u0026#39;div\u0026#39;); pluginContainer.className = `.${name}__plugin`; pluginContainer.innerHTML = plugin.render(this.options.data); this.container.appendChild(pluginContainer); plugin.action(this); }); } render(data) { /* abstract */ return \u0026#39;\u0026#39; } } Slider继承自Component\nclass Slider extends Component{ constructor(id, opts = {name: \u0026#39;slider-list\u0026#39;, data:[], cycle: 3000}){ super(id, opts); this.items = this.container.querySelectorAll(\u0026#39;.slider-list__item, .slider-list__item--selected\u0026#39;); this.cycle = opts.cycle || 3000; this.slideTo(0); } // 重写render函数 render(data){ const content = data.map(image =\u0026gt; ` \u0026lt;li class=\u0026#34;slider-list__item\u0026#34;\u0026gt; \u0026lt;img src=\u0026#34;${image}\u0026#34;/\u0026gt; \u0026lt;/li\u0026gt; `.trim()); return `\u0026lt;ul\u0026gt;${content.join(\u0026#39;\u0026#39;)}\u0026lt;/ul\u0026gt;`; } // ...其它方法 } 上面的Component类已经是一个组件框架了，它支持定义一个组件和注册插件的功能。\n总结 # 根据上面几个步奏，我们已经完成了组件的插件化、模板化和抽象化。 这个抽象出来的框架虽小，但对于日常业务来说完全够用了。 但它并没有考虑到组件嵌套，这里直接将插件分离出来了。 如果想要进阶完善，可以将插件作为子组件整合进框架里。 另外，模板化这里只考虑到了html，如果要修改组件还要手动修改css，可以思考如何将css也进行模板化。\n","date":"21 十月 2022","permalink":"/posts/js/","section":"Posts","summary":"通过实现和封装一个轮播图组件，由浅入深地理解什么才是优秀的js代码。","title":"JS之组件封装"},{"content":"","date":"21 十月 2022","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"git体系 # 由上图可以看出，git主要由两部分组成，一个是远端仓库，一个是本地仓库。 本地仓库又由一下几个部分组成：\n工作区：就是我们平时写代码的地方，比如我最常用的就是vscode 暂存区：我们运行git add命令时，代码就会被推到暂存区，起到一个缓存的作用，同时也能帮Git在做diff的时候提高查找性能 本地分支：运行git commit命令后，代码就被提交到本地分支上了，可以在本地.git目录下的refs/heads目录中查看到本地的分支代码信息 远端分支本地副本：执行pull、fetch、push指令时都会往这里更新，它是远程仓库各分支数据在本地的一个副本，.git文件下的refs/remotes目录可以查看到具体信息 git工作流程 # 日常工作中，我们常用流程大概是这样：\n在github上建一个新的远程库，或者远程库中已经有数据了\ngit init # 这时本地还没有库，我们先用git init命令初始化一个git仓库\n现在远程、本地都有仓库了，但是二者没有任何关联，将他们联系起来有两种情况\ngit remote # 如果远程仓库是新建的，没有任何数据，我们需要使用git remote add origin xxx.git添加一个远程版本库到本地， 相应的git remote rm命令是删除远程版本库关联。\n然后使用git push -u origin master把当前仓库的master分支和远端仓库的master分支关联起来，这样后续我们push或者pull的时候就可以直接输git push/pull，而不是git push\\pull origin master。\ngit push后面的-u是什么意思 # 给git push加一个-u参数，其实就相当于给本地分支定义一个上游分支，让git知道当前操作的是哪条分支。 相当于同时执行了git push origin master和git branch --set-upstream master origin/master 如果一开始没有代入这个参数，直接运行git pull指令时，会出现以下报错 大概意思是没找到当前分支\ngit clone # 如果远程库已经有数据了，可以直接在本地库使用git clone xxx.git命令将远程库克隆到本地\n这时我们默认是在master分支上\n当我们在上面的命令行后添加参数git clone xxx.git -b branch时，会自动给我切换到branch分支上\ngit branch # 关于分支的操作有这些：\ngit branch：查看本地所有分支信息 git branch -r：查看远程仓库所有分支 git branch -a：查看本地和远程仓库所有分支 git checkout # 如果我们想以当前分支为基准创建一个新的本地分支并切换过去，可以使用git checkout -b branch1命令， 它其实是两个命令合并而成的：git branch branch1创建分支，git checkout branch1切换到该分支上。\ngit add # 当我们在工作区吭哧吭哧敲完代码，根据流程，我们得先把代码添加到暂存区，就需要用到git add命令了\n我们可以一个一个文件添加到暂存区：git add [filename1] [filename2] ... 或者把当前目录下所有文件改动都一口气添加到暂存区：git add . 又或者直接把仓库里所有文件改动都添加到暂存区：git add -A git commit # 然后我们就需要把代码推到本地分支上去了：git commit [filename1] ... -m [mesaage] 这个命令有两个参数：\n-m：后面跟的是本次提交的相关信息，可以简单地描述一下本次提交代码做了哪些改动，添加了什么功能 -a：对于已经被commit提交过的代码，这个命令相当于执行了git add -A，不需要另外再add一遍了； 对于没有被提交过的文件，还是需要add后才能被commit到本地分支上去 一般工作中更多的是使用git commit -m 'do sth'这个命令，也可以使用git commit -am命令，相当于同时执行了git add和git commit。\ngit rm # 有添加就有删除，当我们不小心把不需要提交的文件提交到本地仓库了，可以使用git rm [filename]将其删除。\ngit rm -r dist可以直接删除一个目录。\ngit push # 接下来就要正是把代码推送到远程仓库里去了。\n如果我们至始至终都在master分支上工作，并且之前初始化本地仓库时运行了git push -u origin master命令，现在只需要输入git push指令就ok了。\n如果我们是要将本地创建的分支推送到远端，就需要使用git push --set-upstream origin branch1将分支推上去并关联起来。\n有没有觉得这行代码很熟悉？上面git pull的报错图推荐的指令是git branch --set-upstream-to=origin/\u0026lt;branch\u0026gt; test，就是将本地分支和远程分支关联起来。\n如果远程仓库中已经有了这个分支时，本地代码没有和远程代码冲突的情况下会直接将本地改动提交上去；\n如果出现冲突，就会提示你先把远端分支中的代码pull下来解决冲突，然后再推上去。\ngit pull # 当本地分支和远端分支已经建立联系了，我们只需要git pull就能把代码拉到本地，但如果出现上面的情况，\n两端没能建立联系，就需要使用git pull origin branch1拉取指定的远端分支到本地分支。\n冲突解决后再运行git push --set-upstream origin branch1。\ngit fetch # 当远端仓库对应分支的代码有了新的变更，而当前工作区的代码还没有修改完成，就可使用git fetch将远端代码先拉到本地仓库\ngit merge # 等本地代码写完并提交到本地仓库了，需要合并一下远端分支的更改，就可使用git merge origin/[branchname]。 也可以将指定分支的代码合并到当前分支：\ngit checkout master切换到master分支，git pull拉取最新代码 切回开发分支，执行git merge master合并master代码到开发分支中 和上面的代码实现的效果是一样的，只是所有修改都在开发分支里了，master分支上并没有我们提交的修改。 等修改测试后没有问题可以上线了，再切换到master分支，用git merge origin/[branch1]把分支合并到主分支上，然后git push origin master git log # 提交代码后都可以通过这个指令看到提交记录，这个主要是用来进行代码版本的回滚等操作的\ngit reset # 这个指令后面跟着一个参数和一个版本信息。 在你查看git log的时候，会有一行信息大概长这样\ncommit e55c4d273141edff401cbc6642fe21e14681c258 (HEAD -\u0026gt; branch1, origin/branch1) commit后面这一串数字就是这个版本信息，一般都很长，我们可以只复制前7位。 git reset有三个参数：\n--soft：如果你已经将改动commit到本地仓库，git reset --soft e55c4d2可以让本地仓库的内容回到e55c4d2这一次提交，但暂存区和工作区的内容还在 --mixed：默认参数，暂存区的内容也会回到指定回滚的版本，工作区的改动还在 --hard：直接连工作区的代码都回滚到指定版本，之前所有改动都没有了 git relog # 当你reset之后，在看git log会发现，回滚版本后的所有提交历史都不见了，最新提交记录就是你此时回滚到的版本。 但你发现之后的代码提交中有一部分你依然需要，就可以使用git relog看到所有的操作记录了，然后就可以CV需要的代码了。\ngit revert # 这是一个温和版的reset。 reset相当于时间穿越，让你穿越到指定的提交，所以git log看不到reset版本后的记录； 而resvet是产生一个新的提交，把你改动的代码都恢复到指定版本的样子。\ngit cherry-pick # 一个不常用，但可以救人于水火的功能。 我是小白的时候，在修改代码时总是会忘记切换分支，直接就在master上改了，如果代码已经被commit到本地仓库，就可以git log查看提交记录，复制本应该在分支上提交的commitId，如果有多个提交就全都复制下来，然后切换到需要修改的分支上，使用git cherry-pick master commitId1 commitId2 ...指令。 之后别忘了在master分支上用reset或者revert回滚一下代码。\ngit tag # 如果一个项目一直有人维护、更新迭代，就会给它打上标签标注版本。 标签有两种：轻量标签和附注标签\n轻量标签 # 创建指令：git tag v1.0.0 一旦创建了标签，就基于当前分支创建了一个不可变的分支，当你切换到这个分支并做任何修改并提交，都无法在分支历史中找到记录，它会帮你生成一个独立提交，commitId可以在如图左下角查看到 你可以通过commitId切换到本次提交，如果需要保留当前提交，可以使用git switch -c \u0026lt;new-branch-name\u0026gt;创建一个新分支， 否则直接git switch -丢弃这次提交。\n附注标签 # 创建指令：git tag -a v1.0.1 -m \u0026quot;发布正式版 1.0.1\u0026quot; 比轻量标签多了两个参数，同时也能保留更多信息，它是存储在Git数据库中的一个完整对象。 git show可以看到标签信息。\n推送标签 # git push origin tagName 创建完标签就能把它推送到远端了。\n其它命令 # git tag：查看标签 git tag -l v1.0.1：筛选标签 git tag -d v1.0.1：删除本地标签 git push origin --delete v1.0.2：删除远程标签 git rebase # rebase常常会和merge作比较，从字面意义上看，rebase就是改变基准库。 假设有两个分支，一个master，一个feature 由上图可以看出feature是基于master分支的B节点创建的，之后，在master分支上有一个新提交M，而feature上有两个新提交，C和D。 当我们输入以下指令\ngit checkout feature git rebase master 提交节点就变成了这样 feature的基底变成了M节点，并且feature上的提交合并到了新基底后面。 如果在rebase时，master分支上没有新提交，那么就不存在换基，效果跟merge就一样了，只是merge指令会多一条记录merge操作的提交记录。 实际工作中建议还是使用merge，因为日志会把每一次提交都记录下来，而rebase会让日志呈线性显示，无法得知最初支线是从哪个节点拉取出来的。\nstash # 最后说一个特殊区域，git本地除了工作区、暂存区和本地分支外，还有个储存区。 一般我使用它的场景是， 在一个分支工作了一会，突然需要切换到另一个分支上去，又不好把未完成的代码推上去， 就先git stash把变更保存在本地， 等另一个分支的问题解决之后，切换到之前的分支git stash pop把最新stash的更改加回来。 但并不是很推荐这样用，因为一旦忘记就麻烦了。\n常用命令 # git stash save 'xxx'：存储变更，如果直接git stash会自动分配储存记录标记 git stash list：查看储存区的所有提交列表 git stash pop：弹出并引用最近一次存储区的代码提交 git stash drop stash@{n}：删除某次储存记录 git stash clear：清除所有stash信息 参考文章 # 《Git体系介绍+常用命令及其应用场景》 《git中push -u是什么意思》 《git rebase详解（图解+最简单示例，一次就懂）》 ","date":"16 十月 2022","permalink":"/posts/git/","section":"Posts","summary":"大致介绍Git的构成和工作流程。在流程介绍和部分场景介绍中穿插对Git指令的讲解。","title":"Git查漏补缺"},{"content":"为什么选择Hugo # Hugo是由Go语言实现的，无需搭建复杂的运行环境，几行命令行就能快速生产一个静态网站。 官网提供了多种风格的免费主题，还有优秀网站展示，满足了个人的自定义需求。\n如何搭建 # 就像前面所说，只需要几行命令行就能够搭建出一个属于自己的博客。\n安装Hugo # 首先得安装Hugo(git下载)。 Mac可直接使用brew install hugo安装。 windows系统安装完Hugo后需要配置环境变量，在命令行中输入hugo version来测试是否安装成功。\n生成站点 # 输入命令行\nhugo new [网站名称] [本地存放目录地址] 就可在你想要的目录中生成网站文件。\n创建文章 # hugo new post/first.md 输入以上命令行就可在post目录下生成一个名为first的markdown格式文件。 打开文件大概长这样：\n--- date: \u0026#34;2015-10-25T08:36:54-07:00\u0026#34; title: \u0026#34;first\u0026#34; draft: true ## draft为true表示当前文章是草稿 --- ###文章正文在这 设置主题 # 在官网提供的主题中选择自己心仪的主题，一般点进主题页都会有下载和配置文档，万变不离其宗。 当前我使用的主题叫congo，使用的是git submodule方式下载的：\ncd [网站文件根目录] git init git submodule add -b stable https://github.com/jpanther/congo.git themes/congo 命令行中的地址是主题在git上的地址，后面跟着的是主题存放目录和主题文件名。 当然还有其它的下载方式，可以参考congo文档。\n本地运行 # 然后我们就可以本地启动服务进行调试了：\nhugo server --theme=congo --buildDrafts theme=congo是设置主题，buildDrafts是指生成草稿，还记得前面文章中有个参数draft: true吗？如果没有这个命令，是看不到草稿文章的，需要将draft设为false才能显示在博客上。 然后就可以在浏览器打开http://localhost:1313预览本地博客了。\n部署到服务器 # 作为一个程序员，能免费的东西绝不花钱。这里我们就能用github提供的免费服务器来部署我们的博客，首先得在github上建一个新的库，库的名称设为[github用户名(全小写)].github.io.git。 在网站存放的根目录执行命令：\nhugo --theme=congo --baseUrl=\u0026#34;https://[github用户名(全小写)].github.io/\u0026#34; 后面的地址就是访问在线博客的地址。 命令行运行后，根目录下会有个public文件夹，把这个文件夹里的内容推到刚刚创建的github库里就完成部署了。\ncd public git init git remote add origin [github库的完整地址] git add -. git commit -m \u0026#39;fist commit\u0026#39; git push -u origin master ","date":"15 十月 2022","permalink":"/posts/first-blog/","section":"Posts","summary":"自从typora收费之后，就没有找到一个用着存粹又得心应手的笔记软件了，干脆自己搞一个博客玩玩。本文简单记录了使用Hugo建博的过程。","title":"关于个人博客的建成"},{"content":"","date":"15 十月 2022","permalink":"/about/","section":"HeleneWoods","summary":"","title":"关于我"},{"content":"","date":"1 一月 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 一月 0001","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]